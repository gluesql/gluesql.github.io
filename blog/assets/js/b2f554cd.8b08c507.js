"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"revolutionizing-databases-by-unifying-query-interfaces","metadata":{"permalink":"/blog/revolutionizing-databases-by-unifying-query-interfaces","source":"@site/blog/2023-05-30-revolutionizing-databases-by-unifying-query-interfaces.md","title":"GlueSQL - Revolutionizing Databases by Unifying Query Interfaces","description":"GlueSQL - Revolutionizing Databases by Unifying Query Interfaces","date":"2023-05-30T00:00:00.000Z","formattedDate":"May 30, 2023","tags":[{"label":"gluesql","permalink":"/blog/tags/gluesql"},{"label":"query-interface","permalink":"/blog/tags/query-interface"},{"label":"database","permalink":"/blog/tags/database"},{"label":"proposal","permalink":"/blog/tags/proposal"}],"readingTime":13.07,"hasTruncateMarker":false,"authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"frontMatter":{"title":"GlueSQL - Revolutionizing Databases by Unifying Query Interfaces","description":"GlueSQL - Revolutionizing Databases by Unifying Query Interfaces","slug":"revolutionizing-databases-by-unifying-query-interfaces","authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"tags":["gluesql","query-interface","database","proposal"]},"nextItem":{"title":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","permalink":"/blog/test-driven-documentation"}},"content":"## Introduction\\nGlueSQL is a versatile database project designed for exceptional portability across a broad range of environments, from embedded systems and servers to web and mobile platforms. The core goal is to support diverse storage environments and manage various data types with a standard SQL approach.\\n\\nImagine handling files like CSV, JSONL, and Parquet, or transforming key-value or NoSQL databases such as RocksDB, Redis, and MongoDB into SQL-supporting databases\u2014all feasible with GlueSQL. It can also operate with storages supported in web browsers.\\n\\nGlueSQL\'s essential feature is providing a management layer for these diverse storage scenarios without requiring data migration. The broader aim is to facilitate portability of GlueSQL to any environment supporting read or read-write operations. This extends to APIs like GitHub, or messengers like Discord or Slack.\\n\\nGlueSQL supports both structured and unstructured data and is written in Rust for compatibility with various environments. While portability is its core value, the emphasis is on creating an intuitive, comfortable development environment for easy custom storage implementation.\\n\\nUltimately, GlueSQL aims to significantly reduce the cost, time, and complexity of developing new databases. By leveraging GlueSQL for the parser, planner, and execution layer, developers can focus on creating specific storage implementations, leading to a more convenient query interface like SQL for many environments.\\n\\n## The Problem: Why Reinvent the Database?\\nDespite the numerous database implementations that currently exist, the emergence of new databases continues. The primary reason behind this trend is our need for databases for a broad spectrum of distinct purposes. For instance, new databases are surfacing that are specifically optimized for Large Language Models (LLMs) like ChatGPT. The range is wide and diverse, encompassing embedded databases, OLAP for data analysis, OLTP databases optimized for online transactions, databases specialized for time-series data processing, and many more.\\n\\nWith such varied requirements, we find ourselves in constant need of fresh databases. However, constructing a database from scratch is a monumental task. It necessitates defining a query interface for handling the database and implementing a corresponding parser. Moreover, a separate execution layer for running operations must be built. Also, the planning layer, which is responsible for devising execution strategies, is a vital aspect of this process. Let\'s not forget about the critical storage layer that physically reads and stores the data. In a nutshell, there\'s a daunting amount of work involved in developing a new database.\\n\\nGiven these circumstances, it\'s understandable why numerous emerging databases resort to high pricing structures\u2014they need immediate revenue to offset continuous development costs.\\n\\nBut the story doesn\'t end here. Query interfaces like SQL are indeed useful for serious tasks, but they also provide excellent utility for handling simple log files such as CSV, JSONL, Parquet, and even for utilizing REST APIs for various applications. The issue arises when a complex query interface needs to be provided even for these lighter storage requirements\u2014it necessitates a development process almost identical to building a sophisticated database. Implementing an entire parser and execution layer just to add SQL support to an existing service can seem like an excessive burden.\\n\\nWhether it\'s a simple storage environment or a serious task, the key lies in the storage layer, which involves the actual reading and storing of data. So, what if developers focused on implementing these storage mechanisms while the remaining parts could be handled using existing libraries? This is the role that GlueSQL aspires to play.\\n\\n\\n## The Vision of GlueSQL\\nThe GlueSQL project aims to offer a unified query interface for various environments. The goal is to allow anyone to port and use SQL and GlueSQL\'s proprietary query builder, the AST Builder, in any desired environment. This could range from key-value databases, serious NoSQL databases, log files, and even REST API services. Essentially, if a service supports reading or read-writing data, regardless of the data type, it can readily support a complex query interface via GlueSQL.\\n\\nPresently, the GlueSQL project itself directly supports a few storage types as reference storages. These include in-memory storage for non-persistent data handling, sled storage, which is a key-value database written in Rust, JSON storage for handling JSON and JSONL files, and a storage that ports SQL to the web browser\'s IndexedDB. While the GlueSQL Team is primarily developing these, the aim is to allow anyone to create such custom storages for a wide array of purposes, thus enabling them to assemble the database of their choosing.\\n\\nImagine using GlueSQL\'s SQL and AST Builder everywhere, with the simple method of swapping out storages to operate in diverse settings. It could significantly reduce software development costs. Developers wouldn\'t need to learn the different usage methods for each database. Instead, they could focus solely on implementing business logic using the same interface.\\n\\nOur vision is to reduce database development costs by 10 times, or even more than 20 times. We aim to gather diverse database creators under the GlueSQL banner, making it the go-to solution for cost-effective database development.\\n\\n\\n## Benefits to Database Users: Unifying Query Interfaces, Streamlining Software Development, and Reducing Costs\\nFrom the perspective of the users who engage with databases, there has always been the burden of learning different interfaces to interact with each database. The approach required to work with Redis is different from that necessary for MongoDB. Likewise, handling SQL databases necessitates using SQL. Although SQL databases generally use a common SQL, the SQL they support can considerably vary when examined in detail.\\n\\nNaturally, there are legitimate reasons for such differences. Each database focuses on different areas, and to cater to specialized functionalities, they incorporate dedicated interface mechanisms. However, not all application development needs to utilize these database-specific core special functionalities.\\n\\nLet\'s look at a couple of examples:\\n\\nSuppose you\'re developing a back-end application that uses MySQL as the database and Redis for caching. Due to the vast differences in handling SQL databases and Redis, you would have to develop using different methods when storing data.\\n\\nHere\'s another scenario:\\nImagine you\'re implementing a data migration pipeline between various databases and log files. Let\'s say you\'re transferring Parquet to Redis or MongoDB. In this case, you would need to convert data using different methods for each, all of which would be a cumbersome process.\\n\\nIn both of the above examples, GlueSQL can directly address and solve the issues. It offers the convenience of a uniform query interface to deal with these matters. In certain scenarios, even the construction of a data pipeline can potentially be solved with a single SQL query, thanks to GlueSQL.\\n\\n\\n## Benefits to Database Developers: Drastically Lowering Development Costs and Simplifying the Creation of Purpose-Built Databases\\nIf you want to support SQL in the desired environment, using GlueSQL essentially requires you to implement an interface for Storage. There\'s no need to support all functionalities from the beginning. You can start lightly, choosing and implementing storage features suitable for the environment you want to create. To facilitate this, GlueSQL also provides a library in the form of a test suite to easily validate the storage you\'ve implemented.\\n\\nLowering development costs in this way will enable a broader range of developers to support the GlueSQL query interface. As more developers join, a significant synergy can be generated. Designing a query interface from scratch involves a great deal of work, including planning and supporting the interface for different target programming languages.\\n\\nHowever, despite all this hard work, it is not easy to attract database users accustomed to different methods.\\n\\nConsider that the SQL and AST Builder provided by GlueSQL are already securing numerous users. This eliminates the need for efforts to promote a newly planned query interface. Over the years, many new databases have emphasized compatibility with PostgreSQL or MySQL for similar reasons. As GlueSQL places a strong emphasis on portability in its query interface planning, it allows for more flexible configuration according to the desired situation. Through the AST Builder, it also eliminates the cost of porting to different languages.\\n\\nFor many database developers, using GlueSQL can be an optimal choice, as it can save costs and quickly secure users.\\n\\nLet me mention one more thing: what\'s convenient for humans... could be applied to AI as well. Rather than making AI write automation code using different databases, providing a common query interface can be much more efficient.\\n\\n\\n## The Future with GlueSQL\\nGlueSQL has been and will continue to improve and develop new features to enable portability in various environments. Thanks to the schemaless data support added last year, it is now possible to handle both structured data with schema and unstructured data like JSON simultaneously. This has significantly increased the range of storage environments that can be supported.\\n\\nOne of the key features added last year was the AST Builder. This feature allowed us to escape the confines of SQL and provide an interface for comfortably handling data in the programming languages used for development.\\n\\nOf course, improving existing features is extremely important, and there are many new features to be added. As a major development plan this year, we aim to develop features to effectively attach GlueSQL to NoSQL databases with their own planners and execution layers. The GlueSQL query planner, currently at a basic level, will see significant changes this year. With the expansion of this planner, not only NoSQL databases but also other SQL databases could be supported without sacrificing performance using GlueSQL.\\n\\nThe synergy that arises from the combination of different databases is a significant bonus in this process.\\n\\n\\n## The Journey of the GlueSQL Team\\nThe GlueSQL project was first conceived in the fall of 2019, and since then we have been developing it continuously. Personally, I have created various products in a variety of environments, including game development, backend server, and frontend development over the past decade. The experience gained through this process was a major motivation to start the GlueSQL project.\\n\\nTo put it grandly, the inconveniences felt while using different databases in various environments were a major motivation, wouldn\'t you say?\\n\\nThe start was actually a bit simple. Around 2019, I was mainly doing web front-end development. However, the lack of a structured database for state management and internal data processing made it very uncomfortable, especially since I couldn\'t use SQL databases and the like. So I started to lightly create an SQL database that could run on a web browser. Also, I wanted to use Rust, but after failing to introduce it at the company I was working for at the time, I decided to use it in my own project.\\n\\nBut as I started developing, my dreams grew significantly. Beyond a SQL database that simply operates on a web browser, I started envisioning a database that fits the name \\"Glue\\", one that can easily be ported to various environments, and I continue that journey to this day.\\n\\nWhether I took the database project too lightly, or because the features I wanted kept increasing, the content to be developed kept expanding. As a result, I ended up investing full time in the GlueSQL project development for over three years. For a year in between, I even juggled full-time software engineering work alongside GlueSQL development. Currently, I\'m back to developing the GlueSQL project full time, alongside various part-time contributors.\\n\\nNow, we\'re getting very close to the starting point of the picture I wanted to create through GlueSQL, and thankfully, with contributors joining me, I am not alone.\\n\\n\\n## The Sustainability and Business Aspect of GlueSQL\\nI believe that what we create through GlueSQL will make a great contribution to the world and make many software engineers happy. This gives me immense strength to continue developing even in difficult situations. However, we cannot accomplish everything with pure passion alone. As much as the GlueSQL project can make a significant contribution, I also see it as holding great business value.\\n\\nThe business strategy of GlueSQL may be somewhat different from other databases. We distribute the project itself as open source under the Apache-2.0 license, so that anyone can use it fully, and we do not consider pricing methods such as restricting features to the storages we support. In fact, if there is any player who can do it better, there\'s no way to prevent them from taking the GlueSQL project and making it their own.\\n\\nBut we believe that GlueSQL has great potential in this regard. Anyone can participate and they are free to distribute their own storage in the way they want, whether it\'s open source, private, or commercial. This eliminates the need to create something to replace the GlueSQL project. We aim to prevent the need to recreate the wheel that we provide using GlueSQL.\\n\\nMoreover, our GlueSQL team seeks to continually expand our group of developers and companies working with us. During this development process, while they can certainly implement everything on their own, there is also no reason not to collaborate with our GlueSQL Team, especially for databases like NoSQL that have their own planners and execution layers. If you have a REST API and want to enhance convenience through SQL support, you can do it yourself or you can collaborate with us.\\n\\nIn addition, for some storages, we can also participate as players in the same position as other custom storage developers. We plan to expand the GlueSQL ecosystem in various ways, such as technical support and storage development.\\n\\nWe are finally ready to provide GlueSQL to users at the production level. We are accelerating the development of GlueSQL. If you are a company interested in storage development like SQL support, or if you resonate with our vision and want to join us, please contact us at taehoon@gluesql.com.\\n\\n\\n## Conclusion\\nThe continued emergence of new databases is driven by the demand for diverse and specialized databases, such as those optimized for Large Language Models (LLMs) and databases catering to unique requirements, like embedded databases, OLAP, OLTP, and time-series data processing. However, developing a new database from scratch is a significant undertaking, requiring extensive work, which often results in high costs.\\n\\nGlueSQL presents a solution to this challenge by providing a unified query interface that can be ported across various environments, from key-value databases, NoSQL databases, log files, to REST APIs. It allows anyone to create custom storages, reducing the need for developers to build entirely new databases and to learn different usage methods for each database. Instead, they can focus on implementing their business logic using the same interface.\\n\\nFrom a user perspective, GlueSQL offers the convenience of a unified query interface, easing the burden of learning different interfaces for each database. This simplification of interface use can also extend to AI, potentially enhancing the efficiency of AI automation.\\n\\nGlueSQL\'s development plan includes significant enhancements to its query planner and aims to enable effective attachment of GlueSQL to NoSQL databases. The synergy of combining different databases is a valuable bonus in this process.\\n\\nSince its inception in the fall of 2019, the GlueSQL team has continuously developed the project, driven by the desire to mitigate the inconveniences encountered while using different databases in various environments. The journey has been a rewarding one, with the GlueSQL project now at a point where it closely resembles the envisioned product.\\n\\nGlueSQL, distributed under the Apache-2.0 license, is free for anyone to use and adapt. While the GlueSQL team welcomes collaboration with other developers and companies, they also see significant potential for the project as a business venture. The team is working to expand the GlueSQL ecosystem through a variety of initiatives, including technical support and storage development.\\n\\nWith GlueSQL now sufficiently prepared for practical applications, the team invites companies interested in storage development or those who share their vision to join them in their journey of revolutionizing database development."},{"id":"test-driven-documentation","metadata":{"permalink":"/blog/test-driven-documentation","source":"@site/blog/2023-05-30-test-driven-documentation.md","title":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","description":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","date":"2023-05-30T00:00:00.000Z","formattedDate":"May 30, 2023","tags":[{"label":"ChatGPT","permalink":"/blog/tags/chat-gpt"},{"label":"Test-Driven-Documentation","permalink":"/blog/tags/test-driven-documentation"},{"label":"TDD","permalink":"/blog/tags/tdd"},{"label":"Database","permalink":"/blog/tags/database"},{"label":"Documentation","permalink":"/blog/tags/documentation"},{"label":"Automation","permalink":"/blog/tags/automation"}],"readingTime":9.265,"hasTruncateMarker":false,"authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"frontMatter":{"title":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","description":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","slug":"test-driven-documentation","authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"tags":["ChatGPT","Test-Driven-Documentation","TDD","Database","Documentation","Automation"]},"prevItem":{"title":"GlueSQL - Revolutionizing Databases by Unifying Query Interfaces","permalink":"/blog/revolutionizing-databases-by-unifying-query-interfaces"},"nextItem":{"title":"Breaking the Boundary between SQL and NoSQL Databases","permalink":"/blog/breaking-the-boundary-between-sql-and-nosql"}},"content":"## Introduction: GlueSQL and Test-Driven Documentation\\nRecently, the GlueSQL project reached a significant milestone with the release of version 0.14. This new version brings a host of fresh features to the table, yet one of the most notable changes is in the realm of documentation. For the first time, we\'re proud to announce the launch of our official documentation website. Interested readers can explore the full range of user manuals at https://gluesql.org/docs.\\n\\nPrior to this update, the only way to navigate GlueSQL was by manually inspecting the test code within the test suite. With the recent release, however, a comprehensive user manual has been made public to facilitate a more user-friendly experience. We hope that this new addition will prove beneficial to a broad spectrum of users.\\n\\nThe task of compiling an entire database manual in one go was daunting due to the sheer volume of content required. Surprisingly, this process turned out to be smoother than initially anticipated, largely due to the invaluable aid of ChatGPT, which was instrumental in automating much of the document creation. Specifically, around 80% of the SQL Syntax section was generated using this tool.\\n\\nThis remarkable feat was only possible due to the solid foundation of test codes previously established in GlueSQL. In this article, we\'ll share how we managed to leverage ChatGPT in such a unique way. Based on our recent experience of crafting documents grounded in testing, we\'ve begun to consider the possibility of entirely automating document creation, save for the initial stages.\\n\\nAlong with sharing our journey so far, we will also reveal our plans for future test-based automation of documentation within GlueSQL.\\n\\n## Test Codes and Documentation\\nThe GlueSQL project has placed a significant emphasis on writing test codes. This might be a given for a database project; however, the thoroughness of our approach is evident from our line coverage of nearly **99%** for core codes. While we devoted considerable effort to creating these test codes, our primary focus has always been on a different aspect: ensuring that anyone can quickly grasp the content of the tests and easily add new ones.\\n\\nThe intent here is to empower newcomers to GlueSQL to understand the functionality of the software solely by examining integration tests, even in the absence of a user manual.\\n\\nThe integration tests for GlueSQL can be found in the test-suite workspace. For example, here\'s an excerpt of the test code for the INSERT statement:\\n\\n```rust\\ntest_case!(insert, async move {\\n    run!(\\n        \\"\\nCREATE TABLE Test (\\n    id INTEGER DEFAULT 1,\\n    num INTEGER NULL,\\n    name TEXT NOT NULL,\\n);\\"\\n    );\\n\\n    test! {\\n        name: \\"basic insert - single item\\",\\n        sql: \\"INSERT INTO Test (id, num, name) VALUES (1, 2, \'Hi boo\');\\",\\n        expected: Ok(Payload::Insert(1))\\n    };\\n\\n\\n    test! {\\n        sql: \\"INSERT INTO Test VALUES(17, 30, \'Sullivan\');\\",\\n        expected: Ok(Payload::Insert(1))\\n    };\\n\\n    test! {\\n        sql: \\"INSERT INTO Test (num, name) VALUES (28, \'Wazowski\');\\",\\n        expected: Ok(Payload::Insert(1))\\n    };\\n\\n    test! {\\n        sql: \\"SELECT * FROM Test;\\",\\n        expected: Ok(select!(\\n            id  | num | name;\\n            I64 | I64 | Str;\\n            1     2     \\"Hi boo\\".to_owned();\\n            3     9     \\"Kitty!\\".to_owned();\\n            2     7     \\"Monsters\\".to_owned();\\n            17    30    \\"Sullivan\\".to_owned();\\n            1     28    \\"Wazowski\\".to_owned()\\n        ))\\n    };\\n\\n    // ...\\n});\\n```\\n\\nDespite being written in Rust, these test cases are designed to be comprehensible, even to those unfamiliar with the language. Each test is a complete scenario from start to finish, and the results of each operation are readily observable.\\n\\nGiven that identifying results from SELECT operations in the form of Rust enums and structs can be challenging, we actively utilized macros such as `select!` and `select_with_null!`. We\'ve composed the test cases to demonstrate that the INSERT statement can handle a wide range of cases, including specifying all columns, omitting some, or omitting all.\\n\\n```rust\\ntest! {\\n    sql: \\"INSERT INTO Test (id, num) VALUES (1, 10);\\",\\n    expected: Err(InsertError::LackOfRequiredColumn(\\"name\\".to_owned()).into())\\n};\\n```\\n\\nThe tests also include scenarios for expected faulty inputs, indicating the error returns in these situations.\\n\\nBy organizing the tests in this manner, we aim to make it easy for anyone to read and write tests. Our goal was for these tests to serve as \\"documentation\\" for GlueSQL contributors. At the time we were writing these tests, we didn\'t anticipate that they could actually become documentation themselves. But we\'ve come to realize that they have extraordinary potential.\\n\\n## Leveraging ChatGPT\\nWhen we first embarked on writing the User Manual, we were overwhelmed by the sheer volume of content we had to generate. Around the same time, ChatGPT was gaining prominence, and we thought it might be worth trying out, if only to lighten our load slightly.\\n\\nTo our surprise, ChatGPT exceeded our expectations. If the test codes were well written, it was capable of automatically crafting an exceptional document based on them, capturing all essential details.\\n\\nAfter several trials and errors, we settled on the following prompt for document generation. While it\'s still a challenge to use the same prompt for all documentation, we made minor modifications to suit different situations:\\n\\n```\\nI\'m creating an SQL database documentation website, and I\'d like you to help me with one of the pages that introduces the SQL syntax for GlueSQL.\\n\\n1. Please provide the response content in the \\"markdown\\" format, so I can copy and paste it directly. Keep this constraint in mind while writing.  \\n2. Regardless of the language I use, I need the content written in English.  \\n3. I will provide some test case code written in the Rust language, which contains SQL examples. Please write the documentation based on these examples, but feel free to change the table names, column names, and data types as needed. Don\'t include any Rust related content or text in the response. all the response code example should be in plain SQL. \\n4. GlueSQL does not have the VARCHAR type. If you want to use that, please use TEXT instead. You don\'t need to mention this in the response. \\n5. Wrap the entire response text using <pre> and </pre> tags so I can copy all the content easily. \\n\\nNow, I\'d like you to write the following request:  \\nSQL Statement - \\"INSERT\\" \\n\\nHere\'s an example test code you can refer to:\\n\\ntest_case!(insert, async move {\\n    run!(...\\n```\\n\\nGenerally, we used the template above, and copied and pasted the test code from our existing test-suite. We leveraged this method to harness our many tests to assist in the creation of the user manual. In the next section, we\'ll showcase a sample of the documentation generated in this manner. It\'s quite impressive.\\n\\n## Success Case: Automated User Manual of GlueSQL\\nThanks to ChatGPT, the resulting INSERT document page can be viewed at the following link. It\'s important to note that we used ChatGPT 4 for this task. Version 3.5 wasn\'t quite up to the task, and using version 4 was the minimum requirement.\\n\\nhttps://gluesql.org/docs/dev/sql-syntax/statements/data-manipulation/insert\\n\\n![INSERT Statement](./assets/blog-test-driven-documentation-insert.jpg)\\n\\nThe results were quite impressive. ChatGPT neatly categorized the test cases, explained the syntax, outlined constraints, and provided appropriate examples. It didn\'t stop there; it also skillfully recognized error test cases and incorporated them into the documentation, as shown below.\\n\\n![INSERT Statement](./assets/blog-test-driven-documentation-insert-errorcase.jpg)\\n\\nIsn\'t it amazing?\\n\\n## Future Plans: Fully Automating Documentation Generation\\nWhile the current documentation is far from perfect and there are many aspects that can be improved, we see great potential in this approach. We believe it\'s entirely possible to automate the process of writing this kind of document, and writing in general.\\n\\nIn the past, documents like user manuals required a great deal of effort to maintain once they were written. If a document contained real code examples, verifying that the code still worked was often a tedious task. With the ability to automatically generate documentation as we have done here, these issues are no longer problematic.\\n\\nPreviously, you would have to write tests and then also document them separately. If you had to support multiple languages, that would be an additional task. With a tool like ChatGPT, you can automate all of this. All a developer has to do is write the tests. This alone can be sufficient. You can generate documents automatically based on the tests. Eventually, we can even support automatically translating these documents into multiple languages.\\n\\nThe GlueSQL project repository is currently hosted on GitHub and makes good use of various GitHub Actions. We envision a GitHub Action that automatically regenerates a document corresponding to a test when a user modifies the test and raises a Pull Request. Another GitHub Action could automatically translate updated documents into supported languages and create new Pull Requests. The possibilities are truly endless.\\n\\nNot only will this help with document generation, but it will also provide clear guidelines for writing better test code. If we can automatically generate documents based on written tests, the quality of those documents can serve as an indicator of the quality of the tests themselves. This means that a document automation tool can play the role of a good reviewer for tests. It can greatly reduce the time and effort required for painstakingly reviewing the quality of each test. Developers can also write tests without pressure, evaluate their test code by looking at the generated document, and improve it.\\n\\nFurthermore, multi-language support becomes a breeze. In my personal experience as a software engineer over the past decade, developing various products such as games, web services, and applications, I often needed to support multiple languages. Each time, there was no definite solution. The optimal approach varied depending on the situation, and there were many things to consider when entrusting translations, such as effectively communicating the context of the target service to the translator. Moreover, regularly updating content and having it retranslated into various languages was a very tedious process. While I tried to automate as much as possible by creating various tools, I was never fully satisfied. I believe ChatGPT can completely solve these issues. If there is a need to provide project-specific context, all you need to do is prepare a prompt in advance. Instead of having to rely on and wait for professional translators, we can now entrust this task to ChatGPT, and we only need a few people to review the translated content.\\n\\nWe are nearing a world where documentation is no longer a burden for developers.\\n\\n## Conclusion: The Value of Test-Driven Documentation\\nThe use of ChatGPT to generate documentation has proven a significant step forward in the GlueSQL user manual creation process. Through test-driven documentation, we\'ve managed to automate a substantial part of the manual creation process, saving time and effort, and increasing accuracy.\\n\\nMoreover, this process has unveiled a new potential for documentation: the possibility of fully automating document generation. We\'ve seen that quality tests can become quality documentation with the help of AI, leading to more efficient workflows and possibly better test code as a result.\\n\\nThe journey doesn\'t stop here. We envision leveraging this capability further to auto-translate our documents into multiple languages, making our product more accessible to a global audience.\\n\\nAs we progress, we hope that our experience can inspire other developers to explore and embrace the benefits of AI-generated, test-driven documentation. It\'s not just about saving time\u2014it\'s about improving the way we work, communicate, and share knowledge."},{"id":"breaking-the-boundary-between-sql-and-nosql","metadata":{"permalink":"/blog/breaking-the-boundary-between-sql-and-nosql","source":"@site/blog/2023-05-29-breaking-the-boundary.md","title":"Breaking the Boundary between SQL and NoSQL Databases","description":"Breaking the Boundary between SQL and NoSQL Databases","date":"2023-05-29T00:00:00.000Z","formattedDate":"May 29, 2023","tags":[{"label":"sql","permalink":"/blog/tags/sql"},{"label":"database","permalink":"/blog/tags/database"},{"label":"nosql","permalink":"/blog/tags/nosql"}],"readingTime":10.055,"hasTruncateMarker":false,"authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"frontMatter":{"title":"Breaking the Boundary between SQL and NoSQL Databases","description":"Breaking the Boundary between SQL and NoSQL Databases","slug":"breaking-the-boundary-between-sql-and-nosql","authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"tags":["sql","database","nosql"]},"prevItem":{"title":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","permalink":"/blog/test-driven-documentation"},"nextItem":{"title":"Release v0.14","permalink":"/blog/release-v0.14"}},"content":"## Introduction\\nThe divide between SQL and NoSQL databases has often presented challenges in database management. GlueSQL, a unique database maker library, aims to blur this boundary, providing a versatile tool for handling these two distinct types of databases.\\n\\nIn this article, we explore how GlueSQL navigates the features of SQL and NoSQL databases, offering an integrated solution that promotes flexibility and efficiency. With its ability to unify disparate database types, GlueSQL heralds a new age of adaptable database creation and management.\\n\\n## The Interface Perspective: SQL & AST Builder\\nWhen we talk about SQL databases, it\'s almost a given that they support SQL - the standard query language. Although there are slight variations between databases, the convenience of using a similar SQL language across multiple databases cannot be overstated. However, from a software engineer\'s perspective, there\'s room for improvement. In most software development scenarios, a specific programming language is used. SQL is a separate language, which can cause friction when integrating it into your software. As a result, rather than using raw SQL, many developers employ query builders or ORMs to manipulate SQL conveniently using their preferred programming language. Although it\'s not efficient to generate SQL using a query builder and then parse it again in the database, it\'s a practical and effective choice.\\n\\nOn the other hand, NoSQL databases offer different mechanisms. Some of them have their own language similar to SQL, but most provide an interface library developed specifically for each programming language. While SQL databases rely on external query builder libraries to provide an interface for each programming language, NoSQL databases mostly develop and offer these libraries themselves. If we discount the convenience of SQL language, this is one of the major factors that make NoSQL databases more comfortable to use. Since query builder libraries supporting SQL databases often cater to multiple SQL databases, they are limited in fully supporting unique features of each database. NoSQL databases, on the other hand, can freely manage their interface libraries without these restrictions.\\n\\nProviding a query interface for each programming language is not a fundamental difference between SQL and NoSQL, but we generally accept it implicitly.\\n\\nLet\'s see what happens if we break down this boundary, using GlueSQL as an example. As you can see from the SQL postfix, GlueSQL supports SQL and can be classified as an SQL database.\\n\\n```sql\\nCREATE TABLE Glue (id INTEGER, name TEXT);\\n\\nINSERT INTO Glue VALUES (1, \\"hello\\"), (2, \\"gluesql\\");\\n\\nSELECT * FROM Glue WHERE id = 1;\\n```\\n\\nHowever, GlueSQL also supports its own query builder, like a NoSQL database.\\n(Currently, only Rust is supported, but we\'re working on adding support for other languages.)\\n\\n```rust\\ntable(\\"Glue\\")\\n    .create_table()\\n    .add_column(\\"id INTEGER\\")\\n    .add_column(\\"name TEXT\\")\\n    .execute(glue)\\n\\ntable(\\"Glue\\")\\n    .insert()\\n    .values(vec![\\n        vec![num(1), text(\\"hello\\")],\\n        vec![num(2), text(\\"gluesql\\")],\\n    ])\\n    .execute(glue)\\n    .await;\\n\\ntable(\\"Glue\\")\\n    .select()\\n    .filter(col(\\"id\\").eq(1))\\n    .execute(glue)\\n    .await;\\n```\\n\\nLet\'s reconsider the implicit distinction between SQL and NoSQL. GlueSQL indeed supports SQL, but it also officially develops and offers its own query builder. This query builder is not a secondary tool for SQL. While most SQL query builder libraries ultimately generate SQL strings, GlueSQL\'s builder directly creates an AST (Abstract Structure Tree) that is used for execution within GlueSQL. Hence, we call it the AST Builder. This means SQL and the AST Builder are two equally supported interfaces in GlueSQL.\\n\\nThis also offers an additional advantage:\\n\\n```rust\\ntable(\\"Glue\\")\\n    .select()\\n    // 1.\\n    .filter(col(\\"id\\").eq(1))\\n    // 2.\\n    .filter(\\"id = 1\\")\\n    .execute(glue)\\n    .await;\\n```\\n\\nBecause GlueSQL already supports SQL, not only can you use the custom interface in the AST Builder, but you can also use familiar SQL syntax in part. Whether you use `col(\\"id\\").eq(1)` or `\\"id = 1\\"`, you can use it in the way you prefer. The AST Builder interface, although initially unfamiliar, allows a gradual migration similar to writing SQL for your convenience.\\n\\nThus, we\'ve dismantled one of the implicit distinctions between SQL and NoSQL. However, it\'s more of an implicit differentiation than a fundamental one. There are more significant design differences that we\'ll explore next.\\n\\n\\n## Structured & Unstructured Data\\nIn this section, we\'ll discuss how SQL and NoSQL handle data. SQL generally deals with structured data, and recently, it\'s been made to support semi-structured data as well. On the other hand, NoSQL supports schemaless, unstructured data. Then, we\'ll explain in detail how GlueSQL handles these two types of data. The last part of this section will provide a segue into the next section where we\'ll discuss the decomposition of database functions.\\n\\nWhen talking about SQL databases, one aspect is usually considered together: SQL databases have a defined schema.\\n\\n```sql\\nCREATE TABLE Foo (\\n    id INTEGER,\\n    name TEXT,\\n    rate FLOAT NULL\\n);\\n```\\n\\nHowever, these days, SQL databases tend to support semi-structured data types, such as LIST or JSON. But, supporting completely schemaless, unstructured data is a different matter. SQL databases typically require a minimum schema.\\n\\nWhat about NoSQL databases? As NoSQL databases vary significantly, we can\'t make definitive statements. But let\'s consider a typical document database like MongoDB. Unlike SQL databases, it doesn\'t enforce a schema. Essentially, you can insert any form of data directly. Often, NoSQL databases support schemaless data, but they lack features that enforce a schema like SQL. They generally support structure via validation methods, rather than structured access.\\n\\nIs there no choice but to distinguish between structured data and unstructured, schemaless data so clearly? GlueSQL is being developed with the goal of being adaptable in various environments. Being forced to choose regarding this schema constraint was quite inconvenient. We started pondering if we couldn\'t benefit from both aspects - supporting both schema and schemaless data simultaneously, and we eventually found the answer. Let\'s look at how GlueSQL currently solves this issue through familiar SQL examples.\\n\\n```sql\\nCREATE TABLE Names (id INTEGER, name TEXT);\\nINSERT INTO Names VALUES (1, \'glue\'), (2, \'sql\');\\n```\\n\\nYou can create a regular table with a schema like this. But GlueSQL\'s choice for creating a schemaless table is as follows:\\n\\n```sql\\nCREATE TABLE Logs;\\nINSERT INTO Logs VALUES\\n    (\'{ \\"id\\": 1, \\"value\\": 30 }\'),\\n    (\'{ \\"id\\": 2, \\"rate\\": 3.0, \\"list\\": [1, 2, 3] }\'),\\n    (\'{ \\"id\\": 3, \\"rate\\": 5.0, \\"value\\": 100 }\');\\n```\\n\\nIt creates a table without column definitions! If you do this, GlueSQL recognizes the table as schemaless and processes it internally.\\n\\n```sql\\nSELECT id, rate, list[0] FROM Logs WHERE id = 2;\\n```\\n\\nAlthough the way to create the table was a bit special, using it isn\'t much different from the regular SQL SELECT statement. Not only can you differentiate between schema and schemaless when creating tables, but you can also use them interchangeably!\\n\\n```sql\\nSELECT * FROM Names JOIN Logs ON Names.id = Logs.id;\\n/*\\n| id | list    | name | rate | value |\\n|----|---------|------|------|-------|\\n| 1  |         | glue |      | 30    |\\n| 2  |[1, 2, 3]| sql  | 3    |       |\\n*/\\n```\\n\\nHere\'s an example of querying data by INNER JOINing the Names table, which has a schema, and the Logs table, which is schemaless. GlueSQL has resolved this problem by allowing the internal execution layer to handle both vector-type data, for cases where each row has a defined schema, and map-type data for schemaless cases.\\n\\nThanks to this, the variety of storage that can be supported through GlueSQL has expanded significantly. If there were previously limitations to supporting NoSQL databases that support schemaless data, that is no longer the case. The reference storage where you can directly experience this schemaless data support is JSON Storage. It offers features that allow you to deal directly with unstructured data like JSON using GlueSQL.\\n\\nIf GlueSQL starts from the perspective of an SQL database and expands, by providing the AST Builder directly, it once blurs the boundary, and by supporting unstructured data simultaneously, it knocks down the boundary once more. How do you like it?\\n\\n\\n## Decomposing Database Functionality: Breaking Down SQL and NoSQL Features\\nThe distinction between SQL and NoSQL is not just about whether they support unstructured data. Of course, there are examples like unstructured data, which is mainly supported only in NoSQL, but in many cases, SQL databases tend to support more diverse and complex queries. NoSQL often gains other advantages in exchange for reducing the range of query support provided by SQL databases.\\n\\nGlueSQL is ambitious. It has devised a rather interesting method to support all of this through SQL and the AST Builder, with the same interface. When we usually say SQL database, it implicitly assumes that a lot of features have been fully implemented. Create tables by specifying a schema, modify schemas with \\"alter table\\", support both clustered and non-clustered indexes, and support transactions. And there\'s so much more. But the functionality that is naturally supported in SQL databases may not be natural in other environments.\\n\\nLet\'s think about JSON Storage. GlueSQL\'s JSON Storage allows you to handle JSON, JSONL files using SQL and the AST Builder. This JSON Storage does not support atomic operations or transactions. Of course, it would be great if it did, but implementing and executing them would be a significant performance burden. In most cases, when you want to simply browse and handle JSONL files, the overhead caused by transactions can be an unnecessary burden. In this case, you want to handle JSON, JSONL files using SQL, but you don\'t necessarily need transactions.\\n\\nTo meet the requirements of these diverse environments, GlueSQL has separated the functionality of what we usually call an SQL database into multiple independent interfaces.\\n`Store`, `StoreMut`, `AlterTable`, `Transaction`, ..\\nThese are just a few of the various storage interfaces that GlueSQL currently supports.\\nThe way it works can be summarized like this:\\nIf you implement `Store`, you can use `SELECT`.\\nAnd if you implement both `Store` and `StoreMut`, you can support quite a number of basic SQL statements including `SELECT`.\\nYou can manage tables with `CREATE TABLE`, `DROP TABLE`, and handle data using `INSERT`, `UPDATE`, `DELETE` statements.\\nIf you only need to retrieve data, you only need to implement `Store`.\\nIf you want to support the `ALTER TABLE` statement, you can additionally implement the `AlterTable` interface.\\nThe Transaction interface works the same way.\\nThe interesting part is that, except for Store and StoreMut, all other storage interfaces can be implemented independently. GlueSQL allows you to choose and implement only the features you need.\\nAnd it\'s not just about providing interfaces. It also provides integration tests suitable for each situation to verify what you have implemented. You just need to implement the interface and import the corresponding test case for verification.\\n\\nIn addition to supporting both structured and unstructured data simultaneously, GlueSQL provides the ability to divide the functionality of a database into multiple independent features and selectively implement them. This allows GlueSQL to be ported to a wide variety of environments without any burden.\\n\\n## Conclusion\\nGlueSQL, while serving as a database that provides its own reference storage, is fundamentally a library designed to simplify the creation of databases. One of the substantial challenges GlueSQL had to overcome in order to support a diverse array of environments was to address the distinctive features that separate conventional SQL databases from NoSQL databases. GlueSQL achieved this through several innovative approaches, managing to support both categories simultaneously despite their significantly different characteristics.\\n\\nIt offers support for SQL alongside an AST Builder, and accommodates both structured and unstructured data. Additionally, it decomposes database functionalities into multiple independent features, allowing each environment to selectively implement the functionalities it requires.\\n\\nThese unique attributes enable GlueSQL to live up to its \'Glue\' prefix by facilitating effortless porting across various environments. While we have been developing it for several years, there is still much ground to cover. However, the fact that we are now able to introduce it publicly attests to our successful technological validation and completion of a demonstrable level of implementation.\\n\\nThrough GlueSQL, we hope to provide developers with a unified query interface that can be customized according to their needs, thereby enabling them to produce efficient products more effortlessly. There\'s a promising future ahead for GlueSQL, and we look forward to its contributions to the technology community."},{"id":"release-v0.14","metadata":{"permalink":"/blog/release-v0.14","source":"@site/blog/2023-05-27-release-v0.14.md","title":"Release v0.14","description":"Release Note - v0.14","date":"2023-05-27T00:00:00.000Z","formattedDate":"May 27, 2023","tags":[{"label":"v0.14","permalink":"/blog/tags/v-0-14"},{"label":"release-note","permalink":"/blog/tags/release-note"}],"readingTime":10.24,"hasTruncateMarker":false,"authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"frontMatter":{"title":"Release v0.14","description":"Release Note - v0.14","slug":"release-v0.14","authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"tags":["v0.14","release-note"]},"prevItem":{"title":"Breaking the Boundary between SQL and NoSQL Databases","permalink":"/blog/breaking-the-boundary-between-sql-and-nosql"}},"content":"We now provide an official documentation website at **https://gluesql.org/docs**\\n\\n## \ud83d\ude80 Features\\n\\n### \ud83c\udf40 Schemaless data support\\n\\nGlueSQL now supports creating tables without a schema, allowing for both structured and unstructured data to be stored in the same table.\\nTo create a schemaless table, simply run CREATE TABLE without specifying any columns. For more information on querying schemaless data, please refer to the following link: **[querying schemaless data](https://gluesql.org/docs/dev/sql-syntax/statements/querying/schemaless)**\\n\\n```sql\\nCREATE TABLE Bar;\\n```\\n\\nTo insert values,\\n```sql\\nINSERT INTO Bar VALUES\\n    (\'{ \\"name\\": \\"ast\\", \\"value\\": 30 }\'),\\n    (\'{ \\"name\\": \\"glue\\", \\"rate\\": 3.0, \\"list\\": [1, 2, 3] }\'),\\n```\\n\\nThen, selecting values from schemaless table is simple.\\n```sql\\nSELECT name, rate, list[0] FROM Bar WHERE name = \'glue\';\\n```\\n\\ne.g.\\n```sql\\nCREATE TABLE Names (id INTEGER, name TEXT);\\nINSERT INTO Names VALUES (1, \'glue\'), (2, \'sql\');\\n\\nCREATE TABLE Logs;\\nINSERT INTO Logs VALUES\\n    (\'{ \\"id\\": 1, \\"value\\": 30 }\'),\\n    (\'{ \\"id\\": 2, \\"rate\\": 3.0, \\"list\\": [1, 2, 3] }\'),\\n    (\'{ \\"id\\": 3, \\"rate\\": 5.0, \\"value\\": 100 }\');\\n\\nSELECT * FROM Names JOIN Logs ON Names.id = Logs.id;\\n/*\\n| id | list    | name | rate | value |\\n|----|---------|------|------|-------|\\n| 1  |         | glue |      | 30    |\\n| 2  |[1, 2, 3]| sql  | 3    |       |\\n*/\\n```\\n- Schemaless data support [@panarch](https://github.com/panarch) ([#1046](https://github.com/gluesql/gluesql/pull/1046))\\n\\n### \ud83c\udf40 IndexedDB & WebStorage supports in JavaScript package\\n\\nGlueSQL supports handling in-memory, localStorage, sessionStorage, and even IndexedDB using the same SQL syntax. All you need to know is how to specify the `ENGINE` when creating a table.\\n\\ne.g.\\n```sql\\nCREATE TABLE Mem (mid INTEGER) ENGINE = memory;\\nCREATE TABLE Loc (lid INTEGER) ENGINE = localStorage;\\nCREATE TABLE Ses (sid INTEGER) ENGINE = sessionStorage;\\nCREATE TABLE Idb (iid INTEGER) ENGINE = indexedDB;\\n\\nSELECT\\n    mid, lid, sid, iid \\nFROM Mem\\nJOIN Loc\\nJOIN Ses\\nJOIN Idb;\\n```\\n\\n- Apply CompositeStorage to JS package [@panarch](https://github.com/panarch) ([#1084](https://github.com/gluesql/gluesql/pull/1084))\\n\\n### \ud83c\udf40 Data Types - `UINT32`, `UINT64`, `UINT128`, `POINT` and `FLOAT32`\\n- implement f32 data type [@pythonbrad](https://github.com/pythonbrad) ([#1145](https://github.com/gluesql/gluesql/pull/1145))\\n- Implement geometric `POINT` Type and geometric functions [@seonghun-dev](https://github.com/seonghun-dev) ([#1048](https://github.com/gluesql/gluesql/pull/1048))\\n- Add `UINT32`, `UINT64` and `UINT128` data types [@ChobobDev](https://github.com/ChobobDev) ([#1019](https://github.com/gluesql/gluesql/pull/1019))\\n- Add inet datatype [@pythonbrad](https://github.com/pythonbrad) ([#1080](https://github.com/gluesql/gluesql/pull/1080))\\n\\n### \ud83c\udf40 Functions - `APPEND`, `PREPEND`, `RAND`, `FIND_IDX`, `INITCAP` and `CALC_DISTANCE`\\n\\n- Feat : add calc\\\\_distance function [@seonghun-dev](https://github.com/seonghun-dev) ([#1153](https://github.com/gluesql/gluesql/pull/1153))\\n- Add `PREPEND` function for `LIST` data type [@seonghun-dev](https://github.com/seonghun-dev) ([#1149](https://github.com/gluesql/gluesql/pull/1149))\\n- add initcap function [@pythonbrad](https://github.com/pythonbrad) ([#1064](https://github.com/gluesql/gluesql/pull/1064))\\n- Implement `FIND_IDX` function [@zmrdltl](https://github.com/zmrdltl) ([#1100](https://github.com/gluesql/gluesql/pull/1100))\\n- Implement Rand function [@pythonbrad](https://github.com/pythonbrad) ([#1063](https://github.com/gluesql/gluesql/pull/1063))\\n- Add Append Function to LIST DataType [@seonghun-dev](https://github.com/seonghun-dev) ([#1047](https://github.com/gluesql/gluesql/pull/1047))\\n\\n### \ud83c\udf40 Store traits\\n\\n#### User-level custom function\\nBy implementing both the CustomFunction and CustomFunctionMut traits, users can create, use, and delete user-level custom functions. Although GlueSQL plans to continuously add various functions, users may still find them insufficient. In such cases, users can create their own user-level custom functions to supplement the built-in functions. Additionally, if there are repetitive business logic codes, they can be stored as custom functions.\\ne.g.\\n```sql\\nCREATE FUNCTION ADD_ONE (n INT, x INT DEFAULT 1) RETURN n + x;\\n\\nSELECT ADD_ONE(10) AS test;\\n\\nDROP FUNCTION ADD_ONE;\\n```\\n\\n- Support user level sql function [@pythonbrad](https://github.com/pythonbrad) ([#1095](https://github.com/gluesql/gluesql/pull/1095))\\n\\n#### Metadata\\nThe Metadata trait is an optional implementation for providing additional metadata support in GlueSQL. GlueSQL does not enforce any specific metadata implementation, allowing custom storage developers to decide which type of metadata, such as create time, modify time, etc., they want to provide.\\n\\n- Support Metadata trait [@devgony](https://github.com/devgony) ([#1096](https://github.com/gluesql/gluesql/pull/1096))\\n\\n### \ud83c\udf40 Storages\\n\\n#### JSON Storage\\n- Add JsonStorage support to CLI [@devgony](https://github.com/devgony) ([#1135](https://github.com/gluesql/gluesql/pull/1135))\\n- Rename `Jsonl`Storage to `Json`Storage [@devgony](https://github.com/devgony) ([#1128](https://github.com/gluesql/gluesql/pull/1128))\\n- Support `JSON` format in `JSONL storage` [@devgony](https://github.com/devgony) ([#1123](https://github.com/gluesql/gluesql/pull/1123))\\n- Support `Jsonl` Storage [@devgony](https://github.com/devgony) ([#1053](https://github.com/gluesql/gluesql/pull/1053))\\n\\n#### Composite Storage\\n- Add CompositeStorage which bundles multiple storages [@panarch](https://github.com/panarch) ([#1068](https://github.com/gluesql/gluesql/pull/1068))\\n\\n#### IndexedDB Storage\\n- Add IndexedDB storage support [@panarch](https://github.com/panarch) ([#1067](https://github.com/gluesql/gluesql/pull/1067))\\n\\n#### Web Storage\\n- Add WebStorage - support localStorage \\\\& sessionStorage for web browsers [@panarch](https://github.com/panarch) ([#1050](https://github.com/gluesql/gluesql/pull/1050))\\n\\n### \ud83c\udf40 Other new features\\n\\n- Wrap identifiers with double quote (`\\"`) at `to_sql` [@devgony](https://github.com/devgony) ([#1130](https://github.com/gluesql/gluesql/pull/1130))\\n- Support Values Query at ASTBuilder [@devgony](https://github.com/devgony) ([#1041](https://github.com/gluesql/gluesql/pull/1041))\\n- Support `Schema::from_ddl(ddl: &str) -> String` [@devgony](https://github.com/devgony) ([#1089](https://github.com/gluesql/gluesql/pull/1089))\\n- Support column alias for Table, Derived Table [@ding-young](https://github.com/ding-young) ([#1065](https://github.com/gluesql/gluesql/pull/1065))\\n- Support `TableFactor::{Derived, Dictionary, Series}` in AstBuilder [@devgony](https://github.com/devgony) ([#1007](https://github.com/gluesql/gluesql/pull/1007))\\n\\n## \ud83c\udf0a Interface Changes \\n\\n- Remove Store trait related cfg features, [@panarch](https://github.com/panarch) ([#1091](https://github.com/gluesql/gluesql/pull/1091))\\n- Refactor CreateTable.columns from `Vec<ColumnDef>` to `Option<Vec<ColumnDef>>` [@devgony](https://github.com/devgony) ([#1086](https://github.com/gluesql/gluesql/pull/1086))\\n- Remove `MutResult` [@panarch](https://github.com/panarch) ([#1073](https://github.com/gluesql/gluesql/pull/1073))\\n- Update all store mut trait methods to take \\\\&mut self [@panarch](https://github.com/panarch) ([#1072](https://github.com/gluesql/gluesql/pull/1072))\\n- Change StoreMut interface to use \\\\&mut self, not to take ownership [@panarch](https://github.com/panarch) ([#1071](https://github.com/gluesql/gluesql/pull/1071))\\n- Modify default ColumnOption from NOT NULL to NULL [@devgony](https://github.com/devgony) ([#997](https://github.com/gluesql/gluesql/pull/997))\\n\\n## \ud83c\udf1f Improvements\\n\\n- Add a case for insert with source [@devgony](https://github.com/devgony) ([#1211](https://github.com/gluesql/gluesql/pull/1211))\\n- Apply workspace inheritance to remaining Cargo.toml in storages/, [@panarch](https://github.com/panarch) ([#1181](https://github.com/gluesql/gluesql/pull/1181))\\n- Add nullable, key, default to `GLUE_TABLE_COLUMNS` [@devgony](https://github.com/devgony) ([#1177](https://github.com/gluesql/gluesql/pull/1177))\\n- Update core to bundle all errors using error module, [@panarch](https://github.com/panarch) ([#1178](https://github.com/gluesql/gluesql/pull/1178))\\n- Update global Error enum to display with error module prefix [@panarch](https://github.com/panarch) ([#1175](https://github.com/gluesql/gluesql/pull/1175))\\n- fix: typo [@ever0de](https://github.com/ever0de) ([#1161](https://github.com/gluesql/gluesql/pull/1161))\\n- Move the SCHEMA\\\\_PREFIX const into an impl in SledStorage [@garypen](https://github.com/garypen) ([#1151](https://github.com/gluesql/gluesql/pull/1151))\\n- Merge evaluate\\\\_stateless into evaluate, [@panarch](https://github.com/panarch) ([#1132](https://github.com/gluesql/gluesql/pull/1132))\\n- Remove memory-storage dep from JsonStorage/ Cargo.toml [@panarch](https://github.com/panarch) ([#1131](https://github.com/gluesql/gluesql/pull/1131))\\n- Simplify JsonlStorage codes [@panarch](https://github.com/panarch) ([#1126](https://github.com/gluesql/gluesql/pull/1126))\\n- Bump rust version to 1.68 [@ever0de](https://github.com/ever0de) ([#1125](https://github.com/gluesql/gluesql/pull/1125))\\n- Keep `Cargo.lock` [@ever0de](https://github.com/ever0de) ([#1121](https://github.com/gluesql/gluesql/pull/1121))\\n- Replace closure to variable in `data/interval` module [@ever0de](https://github.com/ever0de) ([#1118](https://github.com/gluesql/gluesql/pull/1118))\\n- Add `f64` support to `data::Key` [@panarch](https://github.com/panarch) ([#1114](https://github.com/gluesql/gluesql/pull/1114))\\n- Add Ord impl for Key, [@panarch](https://github.com/panarch) ([#1110](https://github.com/gluesql/gluesql/pull/1110))\\n- join\\\\_expr when in\\\\_subquery, exists expr in join constraint [@ding-young](https://github.com/ding-young) ([#1112](https://github.com/gluesql/gluesql/pull/1112))\\n- Split JS related GitHub action, [@panarch](https://github.com/panarch) ([#1109](https://github.com/gluesql/gluesql/pull/1109))\\n- Fix error handling for `ilike` function on `Literal` being treated as\u2026 [@ever0de](https://github.com/ever0de) ([#1107](https://github.com/gluesql/gluesql/pull/1107))\\n- Remove `Rc` in `validate.rs` [@ever0de](https://github.com/ever0de) ([#1106](https://github.com/gluesql/gluesql/pull/1106))\\n- Remove `Error::Storage` variant [@ever0de](https://github.com/ever0de) ([#1105](https://github.com/gluesql/gluesql/pull/1105))\\n- Replace `Box::pin` to `futures_enum::Stream` [@ever0de](https://github.com/ever0de) ([#1103](https://github.com/gluesql/gluesql/pull/1103))\\n- Remove stream unneeded map ok uses [@panarch](https://github.com/panarch) ([#1104](https://github.com/gluesql/gluesql/pull/1104))\\n- Replace `TryStream` to `Stream` [@ever0de](https://github.com/ever0de) ([#1102](https://github.com/gluesql/gluesql/pull/1102))\\n- Remove `Rc` from `ColumnValidation` [@ever0de](https://github.com/ever0de) ([#1101](https://github.com/gluesql/gluesql/pull/1101))\\n- Remove unneeded Rc uses in fetch\\\\_labels [@panarch](https://github.com/panarch) ([#1098](https://github.com/gluesql/gluesql/pull/1098))\\n- Simplify TryStreamExt using codes in join executor, [@panarch](https://github.com/panarch) ([#1097](https://github.com/gluesql/gluesql/pull/1097))\\n- Fix typo in plan/validate.rs [@ever0de](https://github.com/ever0de) ([#1093](https://github.com/gluesql/gluesql/pull/1093))\\n- Update IdbStorage to use Schema::{to\\\\_ddl, from\\\\_ddl} to manage schema \u2026 [@panarch](https://github.com/panarch) ([#1090](https://github.com/gluesql/gluesql/pull/1090))\\n- Update Cargo.toml files to inherit workspace level configs, [@panarch](https://github.com/panarch) ([#1088](https://github.com/gluesql/gluesql/pull/1088))\\n- Add Error enum to core::prelude [@panarch](https://github.com/panarch) ([#1087](https://github.com/gluesql/gluesql/pull/1087))\\n- Update `StringExt` implementation to use `str` [@ever0de](https://github.com/ever0de) ([#1082](https://github.com/gluesql/gluesql/pull/1082))\\n- Add enum `StrSlice` under enum `Evaluated` [@zmrdltl](https://github.com/zmrdltl) ([#999](https://github.com/gluesql/gluesql/pull/999))\\n- refactor plan::validate::Context.labels from String to str [@devgony](https://github.com/devgony) ([#1079](https://github.com/gluesql/gluesql/pull/1079))\\n- Replace `dyn object` to generic [@ever0de](https://github.com/ever0de) ([#1075](https://github.com/gluesql/gluesql/pull/1075))\\n- Implement ValidationContext(schema\\\\_map + alias) to enhance validation of ambiguous columns [@devgony](https://github.com/devgony) ([#883](https://github.com/gluesql/gluesql/pull/883))\\n- Remove `clone` in `check_table_factor` [@ever0de](https://github.com/ever0de) ([#1058](https://github.com/gluesql/gluesql/pull/1058))\\n- Bump rust-toolchain version to `1.66` [@ever0de](https://github.com/ever0de) ([#1057](https://github.com/gluesql/gluesql/pull/1057))\\n- Bump `sqlparser` version to `0.30` [@ever0de](https://github.com/ever0de) ([#1056](https://github.com/gluesql/gluesql/pull/1056))\\n- Replace `Box::pin` to `futures_enum` in aggregate module [@ever0de](https://github.com/ever0de) ([#1055](https://github.com/gluesql/gluesql/pull/1055))\\n- Update js/ Cargo.toml to use gloo-utils for serde handling [@panarch](https://github.com/panarch) ([#1049](https://github.com/gluesql/gluesql/pull/1049))\\n- Remove ast::ColumnOption and merge UNIQUE option to ColumnDef [@panarch](https://github.com/panarch) ([#1044](https://github.com/gluesql/gluesql/pull/1044))\\n- Rewrite \\\\& simplify plan/context.rs codes, [@panarch](https://github.com/panarch) ([#1045](https://github.com/gluesql/gluesql/pull/1045))\\n- Move ast::ColumnOption::Default variant to ColumnDef [@panarch](https://github.com/panarch) ([#1042](https://github.com/gluesql/gluesql/pull/1042))\\n- [AST-Builder] Remove unused prebuild nodes  [@ding-young](https://github.com/ding-young) ([#1043](https://github.com/gluesql/gluesql/pull/1043))\\n- Remove data::RowError, [@panarch](https://github.com/panarch) ([#1040](https://github.com/gluesql/gluesql/pull/1040))\\n- Reorder project in ASTBuilder (project -> ordery\\\\_by -> limit,offset) [@devgony](https://github.com/devgony) ([#1039](https://github.com/gluesql/gluesql/pull/1039))\\n- Remove unused LimitOffsetNode in AST builder [@panarch](https://github.com/panarch) ([#1038](https://github.com/gluesql/gluesql/pull/1038))\\n- Rename executor/ blend.rs module to project.rs [@SaumyaBhushan](https://github.com/SaumyaBhushan) ([#1036](https://github.com/gluesql/gluesql/pull/1036))\\n- Add Debug to AST builder nodes [@panarch](https://github.com/panarch) ([#1022](https://github.com/gluesql/gluesql/pull/1022))\\n- Bump rust toolchain version to 1.65 [@ever0de](https://github.com/ever0de) ([#1035](https://github.com/gluesql/gluesql/pull/1035))\\n- Remove `Content::Shared` variant in executor/ `RowContext` [@ever0de](https://github.com/ever0de) ([#1032](https://github.com/gluesql/gluesql/pull/1032))\\n- Merge insert logics in row.rs \\\\& execute.rs into executor/insert.rs [@panarch](https://github.com/panarch) ([#1031](https://github.com/gluesql/gluesql/pull/1031))\\n- Merge FilterContext and BlendContext into RowContext [@panarch](https://github.com/panarch) ([#1029](https://github.com/gluesql/gluesql/pull/1029))\\n- Update `data::Row` to contain columns [@panarch](https://github.com/panarch) ([#1026](https://github.com/gluesql/gluesql/pull/1026))\\n- Add LIST type support in CONCAT function [@seonghun-dev](https://github.com/seonghun-dev) ([#1021](https://github.com/gluesql/gluesql/pull/1021))\\n- Remove LimitOffsetNode in AST builder [@panarch](https://github.com/panarch) ([#1023](https://github.com/gluesql/gluesql/pull/1023))\\n- Fix typo [@ever0de](https://github.com/ever0de) ([#1020](https://github.com/gluesql/gluesql/pull/1020))\\n- Add NumericNode to handle numeric value inputs in AST builder [@panarch](https://github.com/panarch) ([#1017](https://github.com/gluesql/gluesql/pull/1017))\\n- Update ValueError::InvalidJsonString error to show input text [@panarch](https://github.com/panarch) ([#1018](https://github.com/gluesql/gluesql/pull/1018))\\n- Add null() func which makes NULL value in AST builder [@panarch](https://github.com/panarch) ([#1016](https://github.com/gluesql/gluesql/pull/1016))\\n- Add --all-targets option to cargo clippy rust gh-action [@panarch](https://github.com/panarch) ([#1015](https://github.com/gluesql/gluesql/pull/1015))\\n- Move import `ColumnOption` used only by `alter-table` feature in ast-builder [@ever0de](https://github.com/ever0de) ([#1014](https://github.com/gluesql/gluesql/pull/1014))\\n- Add value/ binary\\\\_op `Parital{Ord,Cmp}` impl macro [@ever0de](https://github.com/ever0de) ([#1013](https://github.com/gluesql/gluesql/pull/1013))\\n- Change to use internal chrono errors in parsing datetime [@ever0de](https://github.com/ever0de) ([#1010](https://github.com/gluesql/gluesql/pull/1010))\\n- Resolve unreachable branch of `Value::position` [@ever0de](https://github.com/ever0de) ([#1012](https://github.com/gluesql/gluesql/pull/1012))\\n- Apply binary\\\\_op macros to existing data types [@ChobobDev](https://github.com/ChobobDev) ([#987](https://github.com/gluesql/gluesql/pull/987))\\n- chore: Use rust-cache action to cache dependencies [@jongwooo](https://github.com/jongwooo) ([#1006](https://github.com/gluesql/gluesql/pull/1006))\\n- Group the import statements [@yugeeklab](https://github.com/yugeeklab) ([#1005](https://github.com/gluesql/gluesql/pull/1005))\\n- Make Tester::new async [@ShaddyDC](https://github.com/ShaddyDC) ([#1004](https://github.com/gluesql/gluesql/pull/1004))\\n- Make MemoryStorage Store trait features optional, [@panarch](https://github.com/panarch) ([#1003](https://github.com/gluesql/gluesql/pull/1003))\\n- Replace `double quotes` to `identifier` [@devgony](https://github.com/devgony) ([#1001](https://github.com/gluesql/gluesql/pull/1001))\\n- Change chrono `from_*` methods to `from_*_opt` [@ever0de](https://github.com/ever0de) ([#1000](https://github.com/gluesql/gluesql/pull/1000))\\n- Improve duplicate column names validation [@devgony](https://github.com/devgony) ([#995](https://github.com/gluesql/gluesql/pull/995))\\n- Register `lock` when `fetch_all_schemas` face `idle` [@devgony](https://github.com/devgony) ([#996](https://github.com/gluesql/gluesql/pull/996))\\n- Merge ColumnOption::{Null, NotNull} into a single option [@devgony](https://github.com/devgony) ([#986](https://github.com/gluesql/gluesql/pull/986))\\n- Update rust.yml github action to test examples/ [@panarch](https://github.com/panarch) ([#994](https://github.com/gluesql/gluesql/pull/994))\\n\\n\\n## \ud83c\udf33 Documentation\\n\\n**We now provide an official documentation website at https://gluesql.org/docs**\\n\\n- Add documentation for CLI [@devgony](https://github.com/devgony) ([#1183](https://github.com/gluesql/gluesql/pull/1183))\\n- Add ast\\\\_builder null handling doc [@LEE026](https://github.com/LEE026) ([#1209](https://github.com/gluesql/gluesql/pull/1209))\\n- Add document of datetime current date and time for ast-builder [@heewoneha](https://github.com/heewoneha) ([#1208](https://github.com/gluesql/gluesql/pull/1208))\\n- docs: write position and indexing docs [@Bangseungjae](https://github.com/Bangseungjae) ([#1206](https://github.com/gluesql/gluesql/pull/1206))\\n- Add docs/formatting for ast\\\\_builder [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1200](https://github.com/gluesql/gluesql/pull/1200))\\n- Update math basic arithmetic docs for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1202](https://github.com/gluesql/gluesql/pull/1202))\\n- Add pattern-matching doc for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1199](https://github.com/gluesql/gluesql/pull/1199))\\n- Add ast builder Trimming function docs [@Bangseungjae](https://github.com/Bangseungjae) ([#1197](https://github.com/gluesql/gluesql/pull/1197))\\n- Add doc about the function Date \\\\& Time Conversion [@heewoneha](https://github.com/heewoneha) ([#1196](https://github.com/gluesql/gluesql/pull/1196))\\n- add Docs/case conversion(upper, lower, InitCap) in ast builder [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1195](https://github.com/gluesql/gluesql/pull/1195))\\n- Add math conversion docs for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1192](https://github.com/gluesql/gluesql/pull/1192))\\n- Added documentation for the round, ceil, and floor functions in ast-builder [@LEE026](https://github.com/LEE026) ([#1191](https://github.com/gluesql/gluesql/pull/1191))\\n- Add  documentation layout for AstBuilder [@devgony](https://github.com/devgony) ([#1184](https://github.com/gluesql/gluesql/pull/1184))\\n- Add documentation for Json Storage [@devgony](https://github.com/devgony) ([#1170](https://github.com/gluesql/gluesql/pull/1170))\\n- Add documentation for math functions [@panarch](https://github.com/panarch) ([#1173](https://github.com/gluesql/gluesql/pull/1173))\\n- Add doc for datetime, geometry, list \\\\& map and other functions, [@panarch](https://github.com/panarch) ([#1172](https://github.com/gluesql/gluesql/pull/1172))\\n- Add documentation for text functions in SQL [@panarch](https://github.com/panarch) ([#1167](https://github.com/gluesql/gluesql/pull/1167))\\n- Write docs/ Supported Storages section contents, [@panarch](https://github.com/panarch) ([#1165](https://github.com/gluesql/gluesql/pull/1165))\\n- Add SQL function list with categories to docs/ [@panarch](https://github.com/panarch) ([#1166](https://github.com/gluesql/gluesql/pull/1166))\\n- Write docs/getting-started/javascript-web.md [@panarch](https://github.com/panarch) ([#1159](https://github.com/gluesql/gluesql/pull/1159))\\n- Write docs/ Developing Custom Storages contents [@panarch](https://github.com/panarch) ([#1155](https://github.com/gluesql/gluesql/pull/1155))\\n- docs: add newly added data type into README.md [@ChobobDev](https://github.com/ChobobDev) ([#1137](https://github.com/gluesql/gluesql/pull/1137))\\n- docs(readme): add discord icon to chat badge [@LeoDog896](https://github.com/LeoDog896) ([#1122](https://github.com/gluesql/gluesql/pull/1122))\\n- docs(javascript): update examples link [@LeoDog896](https://github.com/LeoDog896) ([#1108](https://github.com/gluesql/gluesql/pull/1108))\\n\\n### Docs - setup\\n\\n- Add gh-action for docs build - runs on both push \\\\& pr [@panarch](https://github.com/panarch) ([#1215](https://github.com/gluesql/gluesql/pull/1215))\\n- Setup blog based on docusaurus, [@panarch](https://github.com/panarch) ([#1212](https://github.com/gluesql/gluesql/pull/1212))\\n- Remove mdbook which is replaced by docs/ (docusaurus based) [@panarch](https://github.com/panarch) ([#1164](https://github.com/gluesql/gluesql/pull/1164))\\n- Add docusaurus deployment github action setup [@panarch](https://github.com/panarch) ([#1163](https://github.com/gluesql/gluesql/pull/1163))\\n- Update coverage, javascript and rust gh action to ignore `docs/**` pa\u2026 [@panarch](https://github.com/panarch) ([#1168](https://github.com/gluesql/gluesql/pull/1168))\\n- Update docs/ global styles, [@panarch](https://github.com/panarch) ([#1156](https://github.com/gluesql/gluesql/pull/1156))\\n- Setup new documentation based on docusaurus [@panarch](https://github.com/panarch) ([#1136](https://github.com/gluesql/gluesql/pull/1136))\\n\\n\\n## \ud83d\udccb Tests\\n\\n- Add ifnull test suite for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1207](https://github.com/gluesql/gluesql/pull/1207))\\n- Add datetime current date and time test case for ast builder [@heewoneha](https://github.com/heewoneha) ([#1205](https://github.com/gluesql/gluesql/pull/1205))\\n- Add Position and Indexing test code [@Bangseungjae](https://github.com/Bangseungjae) ([#1203](https://github.com/gluesql/gluesql/pull/1203))\\n- Add math basic arithmetic test case for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1201](https://github.com/gluesql/gluesql/pull/1201))\\n- Add testcase/formatting for ast\\\\_builder [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1198](https://github.com/gluesql/gluesql/pull/1198))\\n- Add pattern\\\\_matching test cases for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1194](https://github.com/gluesql/gluesql/pull/1194))\\n- Add test code function / text / trimming [@Bangseungjae](https://github.com/Bangseungjae) ([#1190](https://github.com/gluesql/gluesql/pull/1190))\\n- Add Testcase/case conversion [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1193](https://github.com/gluesql/gluesql/pull/1193))\\n- Add datetime conversion test cases for ast\\\\_builder [@heewoneha](https://github.com/heewoneha) ([#1187](https://github.com/gluesql/gluesql/pull/1187))\\n- Add math conversion test case for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1189](https://github.com/gluesql/gluesql/pull/1189))\\n- Add rounding test cases for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1186](https://github.com/gluesql/gluesql/pull/1186))\\n- Update delete and insert tests in test-suite/, [@panarch](https://github.com/panarch) ([#1180](https://github.com/gluesql/gluesql/pull/1180))\\n- Remove gen-\\\\_transaction\\\\_dictionary\\\\_tests! in test-suite, [@panarch](https://github.com/panarch) ([#1179](https://github.com/gluesql/gluesql/pull/1179))\\n- Refactor geometry function tests in test-suite, [@panarch](https://github.com/panarch) ([#1176](https://github.com/gluesql/gluesql/pull/1176))\\n- Refactor SQL function tests in test-suite, [@panarch](https://github.com/panarch) ([#1174](https://github.com/gluesql/gluesql/pull/1174))\\n- fix : fix missing intg test for new data type [@ChobobDev](https://github.com/ChobobDev) ([#1143](https://github.com/gluesql/gluesql/pull/1143))\\n- Add unit tests for `TryFrom<&Value> for Decimal` [@ChobobDev](https://github.com/ChobobDev) ([#1139](https://github.com/gluesql/gluesql/pull/1139))\\n- Add \\"cli\\" unittest [@pythonbrad](https://github.com/pythonbrad) ([#1094](https://github.com/gluesql/gluesql/pull/1094))\\n- Add `core/data` module unit tests [@pythonbrad](https://github.com/pythonbrad) ([#1092](https://github.com/gluesql/gluesql/pull/1092))\\n\\n## \ud83d\udc1b Bug Fixes\\n\\n- Fix docusaurus pages/index broken link [@panarch](https://github.com/panarch) ([#1214](https://github.com/gluesql/gluesql/pull/1214))\\n- Fix docs/ Discord GlueSQL channel invite link address [@panarch](https://github.com/panarch) ([#1213](https://github.com/gluesql/gluesql/pull/1213))\\n- Fix InvalidJsonString error message replacing payload to fileName [@devgony](https://github.com/devgony) ([#1185](https://github.com/gluesql/gluesql/pull/1185))\\n- Fix TryFrom `Value::Str` to `u128` not to use `parse_uuid` [@ChobobDev](https://github.com/ChobobDev) ([#1134](https://github.com/gluesql/gluesql/pull/1134))\\n- Fix column alias with identifer for `TableFactor::Derived` [@ding-young](https://github.com/ding-young) ([#1119](https://github.com/gluesql/gluesql/pull/1119))\\n- Pass data even when `deleted_by` is not present [@ever0de](https://github.com/ever0de) ([#1117](https://github.com/gluesql/gluesql/pull/1117))\\n- Fix MemoryStorage \\\\& WebStorage primary key support [@panarch](https://github.com/panarch) ([#1115](https://github.com/gluesql/gluesql/pull/1115))\\n- Fix `plan::validate` to handle `CTAS` and `ITAS` adding unit test [@devgony](https://github.com/devgony) ([#1074](https://github.com/gluesql/gluesql/pull/1074))\\n- Fix test-suite tester functions to show (found, expected) shape [@panarch](https://github.com/panarch) ([#1028](https://github.com/gluesql/gluesql/pull/1028))"}]}')}}]);