"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6094],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var i=a.createContext({}),p=function(e){var t=a.useContext(i),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(i.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),c=p(n),y=r,m=c["".concat(i,".").concat(y)]||c[y]||d[y]||o;return n?a.createElement(m,s(s({ref:t},u),{},{components:n})):a.createElement(m,s({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=y;var l={};for(var i in t)hasOwnProperty.call(t,i)&&(l[i]=t[i]);l.originalType=e,l[c]="string"==typeof e?e:r,s[1]=l;for(var p=2;p<o;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"},918:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>i,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:11},s="MAP",l={unversionedId:"sql-syntax/data-types/map",id:"sql-syntax/data-types/map",title:"MAP",description:"The MAP data type in GlueSQL is used to store nested key-value pairs, similar to JSON objects. The object keys must be strings, and the values can be any valid data supported by GlueSQL, such as numbers, strings, booleans, null, or even other nested MAP values. Although the input is provided in a JSON object format for convenience, it can store more than just JSON data.",source:"@site/docs/sql-syntax/data-types/map.md",sourceDirName:"sql-syntax/data-types",slug:"/sql-syntax/data-types/map",permalink:"/docs/sql-syntax/data-types/map",draft:!1,tags:[],version:"current",sidebarPosition:11,frontMatter:{sidebar_position:11},sidebar:"sqlSyntaxSidebar",previous:{title:"LIST",permalink:"/docs/sql-syntax/data-types/list"},next:{title:"BYTEA",permalink:"/docs/sql-syntax/data-types/bytea"}},i={},p=[],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"map"},"MAP"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP")," data type in GlueSQL is used to store nested key-value pairs, similar to JSON objects. The object keys must be strings, and the values can be any valid data supported by GlueSQL, such as numbers, strings, booleans, ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", or even other nested ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP")," values. Although the input is provided in a JSON object format for convenience, it can store more than just JSON data."),(0,r.kt)("p",null,"Here is an example of creating a table with a ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP")," data type:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"CREATE TABLE MapType (\n    id INTEGER,\n    nested MAP\n);\n")),(0,r.kt)("p",null,"You can insert data into the table using JSON-like syntax:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},'INSERT INTO MapType VALUES\n    (1, \'{"a": true, "b": 2}\'),\n    (2, \'{"a": {"foo": "ok", "b": "steak"}, "b": 30}\'),\n    (3, \'{"a": {"b": {"c": {"d": 10}}}}\');\n')),(0,r.kt)("p",null,"To access the nested values in a ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP"),", you can use the index operator ",(0,r.kt)("inlineCode",{parentName:"p"},"[]"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT id, nested['a']['foo'] AS foo FROM MapType;\n")),(0,r.kt)("p",null,"This query would return the following result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," id | foo\n----|-----\n  1 | null\n  2 | ok\n  3 | null\n")),(0,r.kt)("p",null,"You can also perform arithmetic operations on nested values, like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT id, nested['a']['b']['c']['d'] * 2 AS good2 FROM MapType;\n")),(0,r.kt)("p",null,"This query would return the following result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"}," id | good2\n----|------\n  1 | null\n  2 | null\n  3 | 20\n")),(0,r.kt)("p",null,"If a specified key does not exist in the ",(0,r.kt)("inlineCode",{parentName:"p"},"MAP"),", the result will be ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."))}d.isMDXComponent=!0}}]);