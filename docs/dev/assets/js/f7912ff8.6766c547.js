"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6834],{5680:(e,a,t)=>{t.d(a,{xA:()=>g,yg:()=>m});var n=t(6540);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=n.createContext({}),u=function(e){var a=n.useContext(o),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},g=function(e){var a=u(e.components);return n.createElement(o.Provider,{value:a},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},c=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,g=l(e,["components","mdxType","originalType","parentName"]),p=u(t),c=r,m=p["".concat(o,".").concat(c)]||p[c]||d[c]||i;return t?n.createElement(m,s(s({ref:a},g),{},{components:t})):n.createElement(m,s({ref:a},g))}));function m(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var i=t.length,s=new Array(i);s[0]=c;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l[p]="string"==typeof e?e:r,s[1]=l;for(var u=2;u<i;u++)s[u]=t[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},2673:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>o,contentTitle:()=>s,default:()=>d,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var n=t(8168),r=(t(6540),t(5680));const i={},s="Parquet Storage Extension for GlueSQL",l={unversionedId:"storages/supported-storages/parquet-storage",id:"storages/supported-storages/parquet-storage",title:"Parquet Storage Extension for GlueSQL",description:"Introduction",source:"@site/docs/storages/supported-storages/parquet-storage.md",sourceDirName:"storages/supported-storages",slug:"/storages/supported-storages/parquet-storage",permalink:"/docs/dev/storages/supported-storages/parquet-storage",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"autoSidebar",previous:{title:"Composite Storage",permalink:"/docs/dev/storages/supported-storages/composite-storage"},next:{title:"Introduction",permalink:"/docs/dev/storages/developing-custom-storages/intro"}},o={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Structure",id:"structure",level:2},{value:"Schema File",id:"schema-file",level:2},{value:"Examples",id:"examples",level:3},{value:"Creating a Table",id:"creating-a-table",level:4},{value:"Inserting Data and Querying",id:"inserting-data-and-querying",level:4},{value:"Updating Data and Querying",id:"updating-data-and-querying",level:4},{value:"Deleting Data and Querying",id:"deleting-data-and-querying",level:4},{value:"Schemaless File Interaction",id:"schemaless-file-interaction",level:2},{value:"Implications",id:"implications",level:3},{value:"Examples",id:"examples-1",level:3},{value:"Creating Schemaless Table, Inserting, and Querying Data",id:"creating-schemaless-table-inserting-and-querying-data",level:4},{value:"Updating Data and Querying",id:"updating-data-and-querying-1",level:4},{value:"Deleting Data and Querying",id:"deleting-data-and-querying-1",level:4},{value:"Limitations",id:"limitations",level:2},{value:"Conclusion",id:"conclusion",level:2}],g={toc:u},p="wrapper";function d(e){let{components:a,...t}=e;return(0,r.yg)(p,(0,n.A)({},g,t,{components:a,mdxType:"MDXLayout"}),(0,r.yg)("h1",{id:"parquet-storage-extension-for-gluesql"},"Parquet Storage Extension for GlueSQL"),(0,r.yg)("h2",{id:"introduction"},"Introduction"),(0,r.yg)("p",null,"The Parquet Storage Extension empowers users to interact with Parquet files through SQL statements efficiently, making the reading and writing of Parquet files straightforward and user-friendly."),(0,r.yg)("h2",{id:"structure"},"Structure"),(0,r.yg)("p",null,"The extension is designed to handle files with a ",(0,r.yg)("inlineCode",{parentName:"p"},".parquet")," extension and performs read and write operations in the path specified by the user. It provides flexibility for creating files with or without a predefined schema using the DDL statement, adjusting to user needs effectively."),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Schema or Schema-less Files Creation:"),"\nUsers can create either schema or schema-less files using the table name defined in the DDL statement. It adjusts the Parquet's schema and field information to align with GlueSQL's constructs, enabling efficient data querying processes.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Data Querying:"),"\nWhen querying data, the extension converts Parquet's schema and field information to GlueSQL's corresponding constructs. This conversion allows users to perform data queries seamlessly, leveraging the uniformity in schema and field information representation.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Data Modification:"),"\nAny changes in the data are reverted from GlueSQL's schema and field information back to Parquet's original constructs before being written back to a ",(0,r.yg)("inlineCode",{parentName:"p"},".parquet")," file. This bidirectional conversion ensures data integrity and consistency between the two formats during read and write operations."))),(0,r.yg)("h2",{id:"schema-file"},"Schema File"),(0,r.yg)("p",null,"With this extension, you can create new schemas using DDL statements and modify data using DML statements, ensuring seamless interaction with Parquet files."),(0,r.yg)("h3",{id:"examples"},"Examples"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"Note:")," ",(0,r.yg)("inlineCode",{parentName:"p"},"{}")," denotes a placeholder that you must replace with actual values.")),(0,r.yg)("p",null,"To start interacting with the Parquet extension, use the following command in your CLI:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sh"},"./gluesql -p {workspace path} -s parquet\n")),(0,r.yg)("h4",{id:"creating-a-table"},"Creating a Table"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"gluesql> CREATE TABLE food (name TEXT);\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"Table created\n")),(0,r.yg)("p",null,"At this point, you can verify the creation of the food.parquet file in the specified path (./)."),(0,r.yg)("h4",{id:"inserting-data-and-querying"},"Inserting Data and Querying"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO food VALUES('sushi'), ('steak');\n\nSELECT * FROM food;\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"2 row inserted\n\n| name  |\n|-------|\n| sushi |\n| steak |\n")),(0,r.yg)("h4",{id:"updating-data-and-querying"},"Updating Data and Querying"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"UPDATE food SET name = 'Nigiri Sushi' WHERE name='sushi';\nSELECT * FROM food;\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"1 row updated\n\n| name         |\n|--------------|\n| Nigiri Sushi |\n| steak        |\n")),(0,r.yg)("h4",{id:"deleting-data-and-querying"},"Deleting Data and Querying"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"DELETE name FROM food WHERE name = 'steak';\nSELECT * FROM food;\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"1 row deleted\n\n| name         |\n|--------------|\n| Nigiri Sushi |\n")),(0,r.yg)("p",null,"Remember to replace placeholders with the appropriate values and paths when using the commands, and follow the structured steps for effective interaction with Parquet files using GlueSQL."),(0,r.yg)("p",null,"In rust."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'let path = "./";\nlet parquet_storage = ParquetStorage::new(path).unwrap();\nlet mut glue = Glue::new(parquet_storage);\nglue.execute("CREATE TABLE food (name TEXT);")\n    .await\n    .unwrap();\n\nglue.execute("INSERT INTO food VALUES(\'sushi\'), (\'steak\');")\n    .await\n    .unwrap();\n\nglue.execute("UPDATE food SET name = \'Nigiri Sushi\' WHERE name=\'sushi\';")\n    .await\n    .unwrap();\n\nglue.execute("DELETE name FROM food WHERE name = \'steak\';")\n    .await\n    .unwrap();\n\nglue.execute("SELECT * FROM food;").await.unwrap();\n')),(0,r.yg)("h2",{id:"schemaless-file-interaction"},"Schemaless File Interaction"),(0,r.yg)("p",null,"Parquet files inherently require a predefined schema. When creating tables without an explicit schema (schemaless tables), this extension establishes a temporary schema utilizing the Map datatype for the parquet file. This functionality ensures that even schemaless instances can process queries and modifications effectively."),(0,r.yg)("h3",{id:"implications"},"Implications"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Ease of Interaction:")," The temporary schema creation allows users to interact with schemaless parquet files with ease, facilitating various operations such as data retrieval and modifications effectively.")),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("p",{parentName:"li"},(0,r.yg)("strong",{parentName:"p"},"Structured Interaction:")," The use of the Map datatype as a temporary schema enables structured interaction with schemaless parquet files, ensuring a smooth user experience."))),(0,r.yg)("h3",{id:"examples-1"},"Examples"),(0,r.yg)("h4",{id:"creating-schemaless-table-inserting-and-querying-data"},"Creating Schemaless Table, Inserting, and Querying Data"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},'CREATE TABLE Logs;\nINSERT INTO Logs VALUES\n    (\'{ "id": 1, "value": 30 }\'),\n    (\'{ "id": 2, "rate": 3.0, "list": [1, 2, 3] }\'),\n    (\'{ "id": 3, "rate": 5.0, "value": 100 }\');\nSELECT id, rate, list FROM Logs WHERE id = 2;\n')),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"Table created\n3 rows inserted\n\n| id | rate | list    |\n|----|------|---------|\n| 2  | 3    | [1,2,3] |\n")),(0,r.yg)("h4",{id:"updating-data-and-querying-1"},"Updating Data and Querying"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"UPDATE Logs SET list='[5,6]' where id = 2;\nSELECT id, rate, list FROM Logs WHERE id = 2;\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"1 row updated\n| id | rate | list  |\n|----|------|-------|\n| 2  | 3    | [5,6] |\n")),(0,r.yg)("h4",{id:"deleting-data-and-querying-1"},"Deleting Data and Querying"),(0,r.yg)("blockquote",null,(0,r.yg)("p",{parentName:"blockquote"},(0,r.yg)("strong",{parentName:"p"},"Caution: Deleting data in a schemaless table removes all the data within it"))),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-sql"},"DELETE from Logs where id = 2;\nSELECT id, rate, list FROM Logs WHERE id = 2;\n")),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-bash"},"1 row deleted\n| id | rate | list |\n")),(0,r.yg)("p",null,"In rust."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-rust"},'let path = "./";\nlet parquet_storage = ParquetStorage::new(path).unwrap();\nlet mut glue = Glue::new(parquet_storage);\nglue.execute("CREATE TABLE Logs;")\n    .await\n    .unwrap();\n\nglue.execute("INSERT INTO Logs VALUES\n    (\'{ "id": 1, "value": 30 }\'),\n    (\'{ "id": 2, "rate": 3.0, "list": [1, 2, 3] }\'),\n    (\'{ "id": 3, "rate": 5.0, "value": 100 }\');")\n    .await\n    .unwrap();\n\nglue.execute("UPDATE Logs SET list=\'[5,6]\' where id = 2;")\n    .await\n    .unwrap();\n\n//Caution: Deleting data in a schemaless table removes all the data within it\nglue.execute("DELETE from Logs where id = 2;")\n    .await\n    .unwrap();\n\nglue.execute("SELECT * FROM food;").await.unwrap();\n')),(0,r.yg)("h2",{id:"limitations"},"Limitations"),(0,r.yg)("ol",null,(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"For Parquet files storing data with ",(0,r.yg)("inlineCode",{parentName:"p"},"parquet::record::api::Field::MapInternal"),", errors are encountered if the key information utilizes a data type other than string as the key.\nThis is attributed to the fact that GlueSQL's HashMap is of type <String, Value>, hence, limiting the use of other data types as keys.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"The interface for reading data in columnar units is currently not supported by GlueSQL, which might result in suboptimal read and write performance.")),(0,r.yg)("li",{parentName:"ol"},(0,r.yg)("p",{parentName:"li"},"Incompatibility with Parquet Physical Types:"))),(0,r.yg)("p",null,"GlueSQL currently lacks support for certain Parquet physical types, specifically INT96 and FIXED_LENGTH_BYTE_ARRAY. As a result, when executing data modification queries like INSERT or UPDATE on Parquet files, the data type for these columns will be transformed. Columns originally in the ",(0,r.yg)("inlineCode",{parentName:"p"},"INT96")," type will be changed to GlueSQL's ",(0,r.yg)("inlineCode",{parentName:"p"},"Int128"),", and those in ",(0,r.yg)("inlineCode",{parentName:"p"},"FIXED_LENGTH_BYTE_ARRAY")," will be converted to GlueSQL's ",(0,r.yg)("inlineCode",{parentName:"p"},"Bytea")," type. This conversion can have implications on data consistency and might necessitate additional transformations when interacting with other systems or tools that expect the original Parquet physical types."),(0,r.yg)("h2",{id:"conclusion"},"Conclusion"),(0,r.yg)("p",null,"Despite certain limitations, this extension significantly simplifies interactions with Parquet files, making GlueSQL a more versatile tool by supporting a popular columnar storage file format."))}d.isMDXComponent=!0}}]);