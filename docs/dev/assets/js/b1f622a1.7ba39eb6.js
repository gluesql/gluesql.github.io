"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1452],{7731:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"test-driven-documentation","metadata":{"permalink":"/docs/dev/blog/test-driven-documentation","source":"@site/blog/2023-05-30-test-driven-documentation.md","title":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","description":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","date":"2023-05-30T00:00:00.000Z","formattedDate":"May 30, 2023","tags":[{"label":"ChatGPT","permalink":"/docs/dev/blog/tags/chat-gpt"},{"label":"Test-Driven-Documentation","permalink":"/docs/dev/blog/tags/test-driven-documentation"},{"label":"TDD","permalink":"/docs/dev/blog/tags/tdd"},{"label":"Database","permalink":"/docs/dev/blog/tags/database"},{"label":"Documentation","permalink":"/docs/dev/blog/tags/documentation"},{"label":"Automation","permalink":"/docs/dev/blog/tags/automation"}],"readingTime":9.265,"hasTruncateMarker":false,"authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"frontMatter":{"title":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","description":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","slug":"test-driven-documentation","authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"tags":["ChatGPT","Test-Driven-Documentation","TDD","Database","Documentation","Automation"]},"nextItem":{"title":"Breaking the Boundary between SQL and NoSQL Databases","permalink":"/docs/dev/blog/breaking-the-boundary-between-sql-and-nosql"}},"content":"## Introduction: GlueSQL and Test-Driven Documentation\\nRecently, the GlueSQL project reached a significant milestone with the release of version 0.14. This new version brings a host of fresh features to the table, yet one of the most notable changes is in the realm of documentation. For the first time, we\'re proud to announce the launch of our official documentation website. Interested readers can explore the full range of user manuals at https://gluesql.org/docs.\\n\\nPrior to this update, the only way to navigate GlueSQL was by manually inspecting the test code within the test suite. With the recent release, however, a comprehensive user manual has been made public to facilitate a more user-friendly experience. We hope that this new addition will prove beneficial to a broad spectrum of users.\\n\\nThe task of compiling an entire database manual in one go was daunting due to the sheer volume of content required. Surprisingly, this process turned out to be smoother than initially anticipated, largely due to the invaluable aid of ChatGPT, which was instrumental in automating much of the document creation. Specifically, around 80% of the SQL Syntax section was generated using this tool.\\n\\nThis remarkable feat was only possible due to the solid foundation of test codes previously established in GlueSQL. In this article, we\'ll share how we managed to leverage ChatGPT in such a unique way. Based on our recent experience of crafting documents grounded in testing, we\'ve begun to consider the possibility of entirely automating document creation, save for the initial stages.\\n\\nAlong with sharing our journey so far, we will also reveal our plans for future test-based automation of documentation within GlueSQL.\\n\\n## Test Codes and Documentation\\nThe GlueSQL project has placed a significant emphasis on writing test codes. This might be a given for a database project; however, the thoroughness of our approach is evident from our line coverage of nearly **99%** for core codes. While we devoted considerable effort to creating these test codes, our primary focus has always been on a different aspect: ensuring that anyone can quickly grasp the content of the tests and easily add new ones.\\n\\nThe intent here is to empower newcomers to GlueSQL to understand the functionality of the software solely by examining integration tests, even in the absence of a user manual.\\n\\nThe integration tests for GlueSQL can be found in the test-suite workspace. For example, here\'s an excerpt of the test code for the INSERT statement:\\n\\n```rust\\ntest_case!(insert, async move {\\n    run!(\\n        \\"\\nCREATE TABLE Test (\\n    id INTEGER DEFAULT 1,\\n    num INTEGER NULL,\\n    name TEXT NOT NULL,\\n);\\"\\n    );\\n\\n    test! {\\n        name: \\"basic insert - single item\\",\\n        sql: \\"INSERT INTO Test (id, num, name) VALUES (1, 2, \'Hi boo\');\\",\\n        expected: Ok(Payload::Insert(1))\\n    };\\n\\n\\n    test! {\\n        sql: \\"INSERT INTO Test VALUES(17, 30, \'Sullivan\');\\",\\n        expected: Ok(Payload::Insert(1))\\n    };\\n\\n    test! {\\n        sql: \\"INSERT INTO Test (num, name) VALUES (28, \'Wazowski\');\\",\\n        expected: Ok(Payload::Insert(1))\\n    };\\n\\n    test! {\\n        sql: \\"SELECT * FROM Test;\\",\\n        expected: Ok(select!(\\n            id  | num | name;\\n            I64 | I64 | Str;\\n            1     2     \\"Hi boo\\".to_owned();\\n            3     9     \\"Kitty!\\".to_owned();\\n            2     7     \\"Monsters\\".to_owned();\\n            17    30    \\"Sullivan\\".to_owned();\\n            1     28    \\"Wazowski\\".to_owned()\\n        ))\\n    };\\n\\n    // ...\\n});\\n```\\n\\nDespite being written in Rust, these test cases are designed to be comprehensible, even to those unfamiliar with the language. Each test is a complete scenario from start to finish, and the results of each operation are readily observable.\\n\\nGiven that identifying results from SELECT operations in the form of Rust enums and structs can be challenging, we actively utilized macros such as `select!` and `select_with_null!`. We\'ve composed the test cases to demonstrate that the INSERT statement can handle a wide range of cases, including specifying all columns, omitting some, or omitting all.\\n\\n```rust\\ntest! {\\n    sql: \\"INSERT INTO Test (id, num) VALUES (1, 10);\\",\\n    expected: Err(InsertError::LackOfRequiredColumn(\\"name\\".to_owned()).into())\\n};\\n```\\n\\nThe tests also include scenarios for expected faulty inputs, indicating the error returns in these situations.\\n\\nBy organizing the tests in this manner, we aim to make it easy for anyone to read and write tests. Our goal was for these tests to serve as \\"documentation\\" for GlueSQL contributors. At the time we were writing these tests, we didn\'t anticipate that they could actually become documentation themselves. But we\'ve come to realize that they have extraordinary potential.\\n\\n## Leveraging ChatGPT\\nWhen we first embarked on writing the User Manual, we were overwhelmed by the sheer volume of content we had to generate. Around the same time, ChatGPT was gaining prominence, and we thought it might be worth trying out, if only to lighten our load slightly.\\n\\nTo our surprise, ChatGPT exceeded our expectations. If the test codes were well written, it was capable of automatically crafting an exceptional document based on them, capturing all essential details.\\n\\nAfter several trials and errors, we settled on the following prompt for document generation. While it\'s still a challenge to use the same prompt for all documentation, we made minor modifications to suit different situations:\\n\\n```\\nI\'m creating an SQL database documentation website, and I\'d like you to help me with one of the pages that introduces the SQL syntax for GlueSQL.\\n\\n1. Please provide the response content in the \\"markdown\\" format, so I can copy and paste it directly. Keep this constraint in mind while writing.  \\n2. Regardless of the language I use, I need the content written in English.  \\n3. I will provide some test case code written in the Rust language, which contains SQL examples. Please write the documentation based on these examples, but feel free to change the table names, column names, and data types as needed. Don\'t include any Rust related content or text in the response. all the response code example should be in plain SQL. \\n4. GlueSQL does not have the VARCHAR type. If you want to use that, please use TEXT instead. You don\'t need to mention this in the response. \\n5. Wrap the entire response text using <pre> and </pre> tags so I can copy all the content easily. \\n\\nNow, I\'d like you to write the following request:  \\nSQL Statement - \\"INSERT\\" \\n\\nHere\'s an example test code you can refer to:\\n\\ntest_case!(insert, async move {\\n    run!(...\\n```\\n\\nGenerally, we used the template above, and copied and pasted the test code from our existing test-suite. We leveraged this method to harness our many tests to assist in the creation of the user manual. In the next section, we\'ll showcase a sample of the documentation generated in this manner. It\'s quite impressive.\\n\\n## Success Case: Automated User Manual of GlueSQL\\nThanks to ChatGPT, the resulting INSERT document page can be viewed at the following link. It\'s important to note that we used ChatGPT 4 for this task. Version 3.5 wasn\'t quite up to the task, and using version 4 was the minimum requirement.\\n\\nhttps://gluesql.org/docs/dev/sql-syntax/statements/data-manipulation/insert\\n\\n![INSERT Statement](./assets/blog-test-driven-documentation-insert.jpg)\\n\\nThe results were quite impressive. ChatGPT neatly categorized the test cases, explained the syntax, outlined constraints, and provided appropriate examples. It didn\'t stop there; it also skillfully recognized error test cases and incorporated them into the documentation, as shown below.\\n\\n![INSERT Statement](./assets/blog-test-driven-documentation-insert-errorcase.jpg)\\n\\nIsn\'t it amazing?\\n\\n## Future Plans: Fully Automating Documentation Generation\\nWhile the current documentation is far from perfect and there are many aspects that can be improved, we see great potential in this approach. We believe it\'s entirely possible to automate the process of writing this kind of document, and writing in general.\\n\\nIn the past, documents like user manuals required a great deal of effort to maintain once they were written. If a document contained real code examples, verifying that the code still worked was often a tedious task. With the ability to automatically generate documentation as we have done here, these issues are no longer problematic.\\n\\nPreviously, you would have to write tests and then also document them separately. If you had to support multiple languages, that would be an additional task. With a tool like ChatGPT, you can automate all of this. All a developer has to do is write the tests. This alone can be sufficient. You can generate documents automatically based on the tests. Eventually, we can even support automatically translating these documents into multiple languages.\\n\\nThe GlueSQL project repository is currently hosted on GitHub and makes good use of various GitHub Actions. We envision a GitHub Action that automatically regenerates a document corresponding to a test when a user modifies the test and raises a Pull Request. Another GitHub Action could automatically translate updated documents into supported languages and create new Pull Requests. The possibilities are truly endless.\\n\\nNot only will this help with document generation, but it will also provide clear guidelines for writing better test code. If we can automatically generate documents based on written tests, the quality of those documents can serve as an indicator of the quality of the tests themselves. This means that a document automation tool can play the role of a good reviewer for tests. It can greatly reduce the time and effort required for painstakingly reviewing the quality of each test. Developers can also write tests without pressure, evaluate their test code by looking at the generated document, and improve it.\\n\\nFurthermore, multi-language support becomes a breeze. In my personal experience as a software engineer over the past decade, developing various products such as games, web services, and applications, I often needed to support multiple languages. Each time, there was no definite solution. The optimal approach varied depending on the situation, and there were many things to consider when entrusting translations, such as effectively communicating the context of the target service to the translator. Moreover, regularly updating content and having it retranslated into various languages was a very tedious process. While I tried to automate as much as possible by creating various tools, I was never fully satisfied. I believe ChatGPT can completely solve these issues. If there is a need to provide project-specific context, all you need to do is prepare a prompt in advance. Instead of having to rely on and wait for professional translators, we can now entrust this task to ChatGPT, and we only need a few people to review the translated content.\\n\\nWe are nearing a world where documentation is no longer a burden for developers.\\n\\n## Conclusion: The Value of Test-Driven Documentation\\nThe use of ChatGPT to generate documentation has proven a significant step forward in the GlueSQL user manual creation process. Through test-driven documentation, we\'ve managed to automate a substantial part of the manual creation process, saving time and effort, and increasing accuracy.\\n\\nMoreover, this process has unveiled a new potential for documentation: the possibility of fully automating document generation. We\'ve seen that quality tests can become quality documentation with the help of AI, leading to more efficient workflows and possibly better test code as a result.\\n\\nThe journey doesn\'t stop here. We envision leveraging this capability further to auto-translate our documents into multiple languages, making our product more accessible to a global audience.\\n\\nAs we progress, we hope that our experience can inspire other developers to explore and embrace the benefits of AI-generated, test-driven documentation. It\'s not just about saving time\u2014it\'s about improving the way we work, communicate, and share knowledge."},{"id":"breaking-the-boundary-between-sql-and-nosql","metadata":{"permalink":"/docs/dev/blog/breaking-the-boundary-between-sql-and-nosql","source":"@site/blog/2023-05-29-breaking-the-boundary.md","title":"Breaking the Boundary between SQL and NoSQL Databases","description":"Breaking the Boundary between SQL and NoSQL Databases","date":"2023-05-29T00:00:00.000Z","formattedDate":"May 29, 2023","tags":[{"label":"sql","permalink":"/docs/dev/blog/tags/sql"},{"label":"database","permalink":"/docs/dev/blog/tags/database"},{"label":"nosql","permalink":"/docs/dev/blog/tags/nosql"}],"readingTime":10.055,"hasTruncateMarker":false,"authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"frontMatter":{"title":"Breaking the Boundary between SQL and NoSQL Databases","description":"Breaking the Boundary between SQL and NoSQL Databases","slug":"breaking-the-boundary-between-sql-and-nosql","authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"tags":["sql","database","nosql"]},"prevItem":{"title":"Test-Driven Documentation - Automating User Manual Creation in GlueSQL","permalink":"/docs/dev/blog/test-driven-documentation"},"nextItem":{"title":"Release v0.14","permalink":"/docs/dev/blog/release-v0.14"}},"content":"## Introduction\\nThe divide between SQL and NoSQL databases has often presented challenges in database management. GlueSQL, a unique database maker library, aims to blur this boundary, providing a versatile tool for handling these two distinct types of databases.\\n\\nIn this article, we explore how GlueSQL navigates the features of SQL and NoSQL databases, offering an integrated solution that promotes flexibility and efficiency. With its ability to unify disparate database types, GlueSQL heralds a new age of adaptable database creation and management.\\n\\n## The Interface Perspective: SQL & AST Builder\\nWhen we talk about SQL databases, it\'s almost a given that they support SQL - the standard query language. Although there are slight variations between databases, the convenience of using a similar SQL language across multiple databases cannot be overstated. However, from a software engineer\'s perspective, there\'s room for improvement. In most software development scenarios, a specific programming language is used. SQL is a separate language, which can cause friction when integrating it into your software. As a result, rather than using raw SQL, many developers employ query builders or ORMs to manipulate SQL conveniently using their preferred programming language. Although it\'s not efficient to generate SQL using a query builder and then parse it again in the database, it\'s a practical and effective choice.\\n\\nOn the other hand, NoSQL databases offer different mechanisms. Some of them have their own language similar to SQL, but most provide an interface library developed specifically for each programming language. While SQL databases rely on external query builder libraries to provide an interface for each programming language, NoSQL databases mostly develop and offer these libraries themselves. If we discount the convenience of SQL language, this is one of the major factors that make NoSQL databases more comfortable to use. Since query builder libraries supporting SQL databases often cater to multiple SQL databases, they are limited in fully supporting unique features of each database. NoSQL databases, on the other hand, can freely manage their interface libraries without these restrictions.\\n\\nProviding a query interface for each programming language is not a fundamental difference between SQL and NoSQL, but we generally accept it implicitly.\\n\\nLet\'s see what happens if we break down this boundary, using GlueSQL as an example. As you can see from the SQL postfix, GlueSQL supports SQL and can be classified as an SQL database.\\n\\n```sql\\nCREATE TABLE Glue (id INTEGER, name TEXT);\\n\\nINSERT INTO Glue VALUES (1, \\"hello\\"), (2, \\"gluesql\\");\\n\\nSELECT * FROM Glue WHERE id = 1;\\n```\\n\\nHowever, GlueSQL also supports its own query builder, like a NoSQL database.\\n(Currently, only Rust is supported, but we\'re working on adding support for other languages.)\\n\\n```rust\\ntable(\\"Glue\\")\\n    .create_table()\\n    .add_column(\\"id INTEGER\\")\\n    .add_column(\\"name TEXT\\")\\n    .execute(glue)\\n\\ntable(\\"Glue\\")\\n    .insert()\\n    .values(vec![\\n        vec![num(1), text(\\"hello\\")],\\n        vec![num(2), text(\\"gluesql\\")],\\n    ])\\n    .execute(glue)\\n    .await;\\n\\ntable(\\"Glue\\")\\n    .select()\\n    .filter(col(\\"id\\").eq(1))\\n    .execute(glue)\\n    .await;\\n```\\n\\nLet\'s reconsider the implicit distinction between SQL and NoSQL. GlueSQL indeed supports SQL, but it also officially develops and offers its own query builder. This query builder is not a secondary tool for SQL. While most SQL query builder libraries ultimately generate SQL strings, GlueSQL\'s builder directly creates an AST (Abstract Structure Tree) that is used for execution within GlueSQL. Hence, we call it the AST Builder. This means SQL and the AST Builder are two equally supported interfaces in GlueSQL.\\n\\nThis also offers an additional advantage:\\n\\n```rust\\ntable(\\"Glue\\")\\n    .select()\\n    // 1.\\n    .filter(col(\\"id\\").eq(1))\\n    // 2.\\n    .filter(\\"id = 1\\")\\n    .execute(glue)\\n    .await;\\n```\\n\\nBecause GlueSQL already supports SQL, not only can you use the custom interface in the AST Builder, but you can also use familiar SQL syntax in part. Whether you use `col(\\"id\\").eq(1)` or `\\"id = 1\\"`, you can use it in the way you prefer. The AST Builder interface, although initially unfamiliar, allows a gradual migration similar to writing SQL for your convenience.\\n\\nThus, we\'ve dismantled one of the implicit distinctions between SQL and NoSQL. However, it\'s more of an implicit differentiation than a fundamental one. There are more significant design differences that we\'ll explore next.\\n\\n\\n## Structured & Unstructured Data\\nIn this section, we\'ll discuss how SQL and NoSQL handle data. SQL generally deals with structured data, and recently, it\'s been made to support semi-structured data as well. On the other hand, NoSQL supports schemaless, unstructured data. Then, we\'ll explain in detail how GlueSQL handles these two types of data. The last part of this section will provide a segue into the next section where we\'ll discuss the decomposition of database functions.\\n\\nWhen talking about SQL databases, one aspect is usually considered together: SQL databases have a defined schema.\\n\\n```sql\\nCREATE TABLE Foo (\\n    id INTEGER,\\n    name TEXT,\\n    rate FLOAT NULL\\n);\\n```\\n\\nHowever, these days, SQL databases tend to support semi-structured data types, such as LIST or JSON. But, supporting completely schemaless, unstructured data is a different matter. SQL databases typically require a minimum schema.\\n\\nWhat about NoSQL databases? As NoSQL databases vary significantly, we can\'t make definitive statements. But let\'s consider a typical document database like MongoDB. Unlike SQL databases, it doesn\'t enforce a schema. Essentially, you can insert any form of data directly. Often, NoSQL databases support schemaless data, but they lack features that enforce a schema like SQL. They generally support structure via validation methods, rather than structured access.\\n\\nIs there no choice but to distinguish between structured data and unstructured, schemaless data so clearly? GlueSQL is being developed with the goal of being adaptable in various environments. Being forced to choose regarding this schema constraint was quite inconvenient. We started pondering if we couldn\'t benefit from both aspects - supporting both schema and schemaless data simultaneously, and we eventually found the answer. Let\'s look at how GlueSQL currently solves this issue through familiar SQL examples.\\n\\n```sql\\nCREATE TABLE Names (id INTEGER, name TEXT);\\nINSERT INTO Names VALUES (1, \'glue\'), (2, \'sql\');\\n```\\n\\nYou can create a regular table with a schema like this. But GlueSQL\'s choice for creating a schemaless table is as follows:\\n\\n```sql\\nCREATE TABLE Logs;\\nINSERT INTO Logs VALUES\\n    (\'{ \\"id\\": 1, \\"value\\": 30 }\'),\\n    (\'{ \\"id\\": 2, \\"rate\\": 3.0, \\"list\\": [1, 2, 3] }\'),\\n    (\'{ \\"id\\": 3, \\"rate\\": 5.0, \\"value\\": 100 }\');\\n```\\n\\nIt creates a table without column definitions! If you do this, GlueSQL recognizes the table as schemaless and processes it internally.\\n\\n```sql\\nSELECT id, rate, list[0] FROM Logs WHERE id = 2;\\n```\\n\\nAlthough the way to create the table was a bit special, using it isn\'t much different from the regular SQL SELECT statement. Not only can you differentiate between schema and schemaless when creating tables, but you can also use them interchangeably!\\n\\n```sql\\nSELECT * FROM Names JOIN Logs ON Names.id = Logs.id;\\n/*\\n| id | list    | name | rate | value |\\n|----|---------|------|------|-------|\\n| 1  |         | glue |      | 30    |\\n| 2  |[1, 2, 3]| sql  | 3    |       |\\n*/\\n```\\n\\nHere\'s an example of querying data by INNER JOINing the Names table, which has a schema, and the Logs table, which is schemaless. GlueSQL has resolved this problem by allowing the internal execution layer to handle both vector-type data, for cases where each row has a defined schema, and map-type data for schemaless cases.\\n\\nThanks to this, the variety of storage that can be supported through GlueSQL has expanded significantly. If there were previously limitations to supporting NoSQL databases that support schemaless data, that is no longer the case. The reference storage where you can directly experience this schemaless data support is JSON Storage. It offers features that allow you to deal directly with unstructured data like JSON using GlueSQL.\\n\\nIf GlueSQL starts from the perspective of an SQL database and expands, by providing the AST Builder directly, it once blurs the boundary, and by supporting unstructured data simultaneously, it knocks down the boundary once more. How do you like it?\\n\\n\\n## Decomposing Database Functionality: Breaking Down SQL and NoSQL Features\\nThe distinction between SQL and NoSQL is not just about whether they support unstructured data. Of course, there are examples like unstructured data, which is mainly supported only in NoSQL, but in many cases, SQL databases tend to support more diverse and complex queries. NoSQL often gains other advantages in exchange for reducing the range of query support provided by SQL databases.\\n\\nGlueSQL is ambitious. It has devised a rather interesting method to support all of this through SQL and the AST Builder, with the same interface. When we usually say SQL database, it implicitly assumes that a lot of features have been fully implemented. Create tables by specifying a schema, modify schemas with \\"alter table\\", support both clustered and non-clustered indexes, and support transactions. And there\'s so much more. But the functionality that is naturally supported in SQL databases may not be natural in other environments.\\n\\nLet\'s think about JSON Storage. GlueSQL\'s JSON Storage allows you to handle JSON, JSONL files using SQL and the AST Builder. This JSON Storage does not support atomic operations or transactions. Of course, it would be great if it did, but implementing and executing them would be a significant performance burden. In most cases, when you want to simply browse and handle JSONL files, the overhead caused by transactions can be an unnecessary burden. In this case, you want to handle JSON, JSONL files using SQL, but you don\'t necessarily need transactions.\\n\\nTo meet the requirements of these diverse environments, GlueSQL has separated the functionality of what we usually call an SQL database into multiple independent interfaces.\\n`Store`, `StoreMut`, `AlterTable`, `Transaction`, ..\\nThese are just a few of the various storage interfaces that GlueSQL currently supports.\\nThe way it works can be summarized like this:\\nIf you implement `Store`, you can use `SELECT`.\\nAnd if you implement both `Store` and `StoreMut`, you can support quite a number of basic SQL statements including `SELECT`.\\nYou can manage tables with `CREATE TABLE`, `DROP TABLE`, and handle data using `INSERT`, `UPDATE`, `DELETE` statements.\\nIf you only need to retrieve data, you only need to implement `Store`.\\nIf you want to support the `ALTER TABLE` statement, you can additionally implement the `AlterTable` interface.\\nThe Transaction interface works the same way.\\nThe interesting part is that, except for Store and StoreMut, all other storage interfaces can be implemented independently. GlueSQL allows you to choose and implement only the features you need.\\nAnd it\'s not just about providing interfaces. It also provides integration tests suitable for each situation to verify what you have implemented. You just need to implement the interface and import the corresponding test case for verification.\\n\\nIn addition to supporting both structured and unstructured data simultaneously, GlueSQL provides the ability to divide the functionality of a database into multiple independent features and selectively implement them. This allows GlueSQL to be ported to a wide variety of environments without any burden.\\n\\n## Conclusion\\nGlueSQL, while serving as a database that provides its own reference storage, is fundamentally a library designed to simplify the creation of databases. One of the substantial challenges GlueSQL had to overcome in order to support a diverse array of environments was to address the distinctive features that separate conventional SQL databases from NoSQL databases. GlueSQL achieved this through several innovative approaches, managing to support both categories simultaneously despite their significantly different characteristics.\\n\\nIt offers support for SQL alongside an AST Builder, and accommodates both structured and unstructured data. Additionally, it decomposes database functionalities into multiple independent features, allowing each environment to selectively implement the functionalities it requires.\\n\\nThese unique attributes enable GlueSQL to live up to its \'Glue\' prefix by facilitating effortless porting across various environments. While we have been developing it for several years, there is still much ground to cover. However, the fact that we are now able to introduce it publicly attests to our successful technological validation and completion of a demonstrable level of implementation.\\n\\nThrough GlueSQL, we hope to provide developers with a unified query interface that can be customized according to their needs, thereby enabling them to produce efficient products more effortlessly. There\'s a promising future ahead for GlueSQL, and we look forward to its contributions to the technology community."},{"id":"release-v0.14","metadata":{"permalink":"/docs/dev/blog/release-v0.14","source":"@site/blog/2023-05-27-release-v0.14.md","title":"Release v0.14","description":"Release Note - v0.14","date":"2023-05-27T00:00:00.000Z","formattedDate":"May 27, 2023","tags":[{"label":"v0.14","permalink":"/docs/dev/blog/tags/v-0-14"},{"label":"release-note","permalink":"/docs/dev/blog/tags/release-note"}],"readingTime":10.24,"hasTruncateMarker":false,"authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"frontMatter":{"title":"Release v0.14","description":"Release Note - v0.14","slug":"release-v0.14","authors":[{"name":"Taehoon Moon","title":"Creator of GlueSQL","url":"https://github.com/panarch","image_url":"https://github.com/panarch.png","imageURL":"https://github.com/panarch.png"}],"tags":["v0.14","release-note"]},"prevItem":{"title":"Breaking the Boundary between SQL and NoSQL Databases","permalink":"/docs/dev/blog/breaking-the-boundary-between-sql-and-nosql"}},"content":"We now provide an official documentation website at **https://gluesql.org/docs**\\n\\n## \ud83d\ude80 Features\\n\\n### \ud83c\udf40 Schemaless data support\\n\\nGlueSQL now supports creating tables without a schema, allowing for both structured and unstructured data to be stored in the same table.\\nTo create a schemaless table, simply run CREATE TABLE without specifying any columns. For more information on querying schemaless data, please refer to the following link: **[querying schemaless data](https://gluesql.org/docs/dev/sql-syntax/statements/querying/schemaless)**\\n\\n```sql\\nCREATE TABLE Bar;\\n```\\n\\nTo insert values,\\n```sql\\nINSERT INTO Bar VALUES\\n    (\'{ \\"name\\": \\"ast\\", \\"value\\": 30 }\'),\\n    (\'{ \\"name\\": \\"glue\\", \\"rate\\": 3.0, \\"list\\": [1, 2, 3] }\'),\\n```\\n\\nThen, selecting values from schemaless table is simple.\\n```sql\\nSELECT name, rate, list[0] FROM Bar WHERE name = \'glue\';\\n```\\n\\ne.g.\\n```sql\\nCREATE TABLE Names (id INTEGER, name TEXT);\\nINSERT INTO Names VALUES (1, \'glue\'), (2, \'sql\');\\n\\nCREATE TABLE Logs;\\nINSERT INTO Logs VALUES\\n    (\'{ \\"id\\": 1, \\"value\\": 30 }\'),\\n    (\'{ \\"id\\": 2, \\"rate\\": 3.0, \\"list\\": [1, 2, 3] }\'),\\n    (\'{ \\"id\\": 3, \\"rate\\": 5.0, \\"value\\": 100 }\');\\n\\nSELECT * FROM Names JOIN Logs ON Names.id = Logs.id;\\n/*\\n| id | list    | name | rate | value |\\n|----|---------|------|------|-------|\\n| 1  |         | glue |      | 30    |\\n| 2  |[1, 2, 3]| sql  | 3    |       |\\n*/\\n```\\n- Schemaless data support [@panarch](https://github.com/panarch) ([#1046](https://github.com/gluesql/gluesql/pull/1046))\\n\\n### \ud83c\udf40 IndexedDB & WebStorage supports in JavaScript package\\n\\nGlueSQL supports handling in-memory, localStorage, sessionStorage, and even IndexedDB using the same SQL syntax. All you need to know is how to specify the `ENGINE` when creating a table.\\n\\ne.g.\\n```sql\\nCREATE TABLE Mem (mid INTEGER) ENGINE = memory;\\nCREATE TABLE Loc (lid INTEGER) ENGINE = localStorage;\\nCREATE TABLE Ses (sid INTEGER) ENGINE = sessionStorage;\\nCREATE TABLE Idb (iid INTEGER) ENGINE = indexedDB;\\n\\nSELECT\\n    mid, lid, sid, iid \\nFROM Mem\\nJOIN Loc\\nJOIN Ses\\nJOIN Idb;\\n```\\n\\n- Apply CompositeStorage to JS package [@panarch](https://github.com/panarch) ([#1084](https://github.com/gluesql/gluesql/pull/1084))\\n\\n### \ud83c\udf40 Data Types - `UINT32`, `UINT64`, `UINT128`, `POINT` and `FLOAT32`\\n- implement f32 data type [@pythonbrad](https://github.com/pythonbrad) ([#1145](https://github.com/gluesql/gluesql/pull/1145))\\n- Implement geometric `POINT` Type and geometric functions [@seonghun-dev](https://github.com/seonghun-dev) ([#1048](https://github.com/gluesql/gluesql/pull/1048))\\n- Add `UINT32`, `UINT64` and `UINT128` data types [@ChobobDev](https://github.com/ChobobDev) ([#1019](https://github.com/gluesql/gluesql/pull/1019))\\n- Add inet datatype [@pythonbrad](https://github.com/pythonbrad) ([#1080](https://github.com/gluesql/gluesql/pull/1080))\\n\\n### \ud83c\udf40 Functions - `APPEND`, `PREPEND`, `RAND`, `FIND_IDX`, `INITCAP` and `CALC_DISTANCE`\\n\\n- Feat : add calc\\\\_distance function [@seonghun-dev](https://github.com/seonghun-dev) ([#1153](https://github.com/gluesql/gluesql/pull/1153))\\n- Add `PREPEND` function for `LIST` data type [@seonghun-dev](https://github.com/seonghun-dev) ([#1149](https://github.com/gluesql/gluesql/pull/1149))\\n- add initcap function [@pythonbrad](https://github.com/pythonbrad) ([#1064](https://github.com/gluesql/gluesql/pull/1064))\\n- Implement `FIND_IDX` function [@zmrdltl](https://github.com/zmrdltl) ([#1100](https://github.com/gluesql/gluesql/pull/1100))\\n- Implement Rand function [@pythonbrad](https://github.com/pythonbrad) ([#1063](https://github.com/gluesql/gluesql/pull/1063))\\n- Add Append Function to LIST DataType [@seonghun-dev](https://github.com/seonghun-dev) ([#1047](https://github.com/gluesql/gluesql/pull/1047))\\n\\n### \ud83c\udf40 Store traits\\n\\n#### User-level custom function\\nBy implementing both the CustomFunction and CustomFunctionMut traits, users can create, use, and delete user-level custom functions. Although GlueSQL plans to continuously add various functions, users may still find them insufficient. In such cases, users can create their own user-level custom functions to supplement the built-in functions. Additionally, if there are repetitive business logic codes, they can be stored as custom functions.\\ne.g.\\n```sql\\nCREATE FUNCTION ADD_ONE (n INT, x INT DEFAULT 1) RETURN n + x;\\n\\nSELECT ADD_ONE(10) AS test;\\n\\nDROP FUNCTION ADD_ONE;\\n```\\n\\n- Support user level sql function [@pythonbrad](https://github.com/pythonbrad) ([#1095](https://github.com/gluesql/gluesql/pull/1095))\\n\\n#### Metadata\\nThe Metadata trait is an optional implementation for providing additional metadata support in GlueSQL. GlueSQL does not enforce any specific metadata implementation, allowing custom storage developers to decide which type of metadata, such as create time, modify time, etc., they want to provide.\\n\\n- Support Metadata trait [@devgony](https://github.com/devgony) ([#1096](https://github.com/gluesql/gluesql/pull/1096))\\n\\n### \ud83c\udf40 Storages\\n\\n#### JSON Storage\\n- Add JsonStorage support to CLI [@devgony](https://github.com/devgony) ([#1135](https://github.com/gluesql/gluesql/pull/1135))\\n- Rename `Jsonl`Storage to `Json`Storage [@devgony](https://github.com/devgony) ([#1128](https://github.com/gluesql/gluesql/pull/1128))\\n- Support `JSON` format in `JSONL storage` [@devgony](https://github.com/devgony) ([#1123](https://github.com/gluesql/gluesql/pull/1123))\\n- Support `Jsonl` Storage [@devgony](https://github.com/devgony) ([#1053](https://github.com/gluesql/gluesql/pull/1053))\\n\\n#### Composite Storage\\n- Add CompositeStorage which bundles multiple storages [@panarch](https://github.com/panarch) ([#1068](https://github.com/gluesql/gluesql/pull/1068))\\n\\n#### IndexedDB Storage\\n- Add IndexedDB storage support [@panarch](https://github.com/panarch) ([#1067](https://github.com/gluesql/gluesql/pull/1067))\\n\\n#### Web Storage\\n- Add WebStorage - support localStorage \\\\& sessionStorage for web browsers [@panarch](https://github.com/panarch) ([#1050](https://github.com/gluesql/gluesql/pull/1050))\\n\\n### \ud83c\udf40 Other new features\\n\\n- Wrap identifiers with double quote (`\\"`) at `to_sql` [@devgony](https://github.com/devgony) ([#1130](https://github.com/gluesql/gluesql/pull/1130))\\n- Support Values Query at ASTBuilder [@devgony](https://github.com/devgony) ([#1041](https://github.com/gluesql/gluesql/pull/1041))\\n- Support `Schema::from_ddl(ddl: &str) -> String` [@devgony](https://github.com/devgony) ([#1089](https://github.com/gluesql/gluesql/pull/1089))\\n- Support column alias for Table, Derived Table [@ding-young](https://github.com/ding-young) ([#1065](https://github.com/gluesql/gluesql/pull/1065))\\n- Support `TableFactor::{Derived, Dictionary, Series}` in AstBuilder [@devgony](https://github.com/devgony) ([#1007](https://github.com/gluesql/gluesql/pull/1007))\\n\\n## \ud83c\udf0a Interface Changes \\n\\n- Remove Store trait related cfg features, [@panarch](https://github.com/panarch) ([#1091](https://github.com/gluesql/gluesql/pull/1091))\\n- Refactor CreateTable.columns from `Vec<ColumnDef>` to `Option<Vec<ColumnDef>>` [@devgony](https://github.com/devgony) ([#1086](https://github.com/gluesql/gluesql/pull/1086))\\n- Remove `MutResult` [@panarch](https://github.com/panarch) ([#1073](https://github.com/gluesql/gluesql/pull/1073))\\n- Update all store mut trait methods to take \\\\&mut self [@panarch](https://github.com/panarch) ([#1072](https://github.com/gluesql/gluesql/pull/1072))\\n- Change StoreMut interface to use \\\\&mut self, not to take ownership [@panarch](https://github.com/panarch) ([#1071](https://github.com/gluesql/gluesql/pull/1071))\\n- Modify default ColumnOption from NOT NULL to NULL [@devgony](https://github.com/devgony) ([#997](https://github.com/gluesql/gluesql/pull/997))\\n\\n## \ud83c\udf1f Improvements\\n\\n- Add a case for insert with source [@devgony](https://github.com/devgony) ([#1211](https://github.com/gluesql/gluesql/pull/1211))\\n- Apply workspace inheritance to remaining Cargo.toml in storages/, [@panarch](https://github.com/panarch) ([#1181](https://github.com/gluesql/gluesql/pull/1181))\\n- Add nullable, key, default to `GLUE_TABLE_COLUMNS` [@devgony](https://github.com/devgony) ([#1177](https://github.com/gluesql/gluesql/pull/1177))\\n- Update core to bundle all errors using error module, [@panarch](https://github.com/panarch) ([#1178](https://github.com/gluesql/gluesql/pull/1178))\\n- Update global Error enum to display with error module prefix [@panarch](https://github.com/panarch) ([#1175](https://github.com/gluesql/gluesql/pull/1175))\\n- fix: typo [@ever0de](https://github.com/ever0de) ([#1161](https://github.com/gluesql/gluesql/pull/1161))\\n- Move the SCHEMA\\\\_PREFIX const into an impl in SledStorage [@garypen](https://github.com/garypen) ([#1151](https://github.com/gluesql/gluesql/pull/1151))\\n- Merge evaluate\\\\_stateless into evaluate, [@panarch](https://github.com/panarch) ([#1132](https://github.com/gluesql/gluesql/pull/1132))\\n- Remove memory-storage dep from JsonStorage/ Cargo.toml [@panarch](https://github.com/panarch) ([#1131](https://github.com/gluesql/gluesql/pull/1131))\\n- Simplify JsonlStorage codes [@panarch](https://github.com/panarch) ([#1126](https://github.com/gluesql/gluesql/pull/1126))\\n- Bump rust version to 1.68 [@ever0de](https://github.com/ever0de) ([#1125](https://github.com/gluesql/gluesql/pull/1125))\\n- Keep `Cargo.lock` [@ever0de](https://github.com/ever0de) ([#1121](https://github.com/gluesql/gluesql/pull/1121))\\n- Replace closure to variable in `data/interval` module [@ever0de](https://github.com/ever0de) ([#1118](https://github.com/gluesql/gluesql/pull/1118))\\n- Add `f64` support to `data::Key` [@panarch](https://github.com/panarch) ([#1114](https://github.com/gluesql/gluesql/pull/1114))\\n- Add Ord impl for Key, [@panarch](https://github.com/panarch) ([#1110](https://github.com/gluesql/gluesql/pull/1110))\\n- join\\\\_expr when in\\\\_subquery, exists expr in join constraint [@ding-young](https://github.com/ding-young) ([#1112](https://github.com/gluesql/gluesql/pull/1112))\\n- Split JS related GitHub action, [@panarch](https://github.com/panarch) ([#1109](https://github.com/gluesql/gluesql/pull/1109))\\n- Fix error handling for `ilike` function on `Literal` being treated as\u2026 [@ever0de](https://github.com/ever0de) ([#1107](https://github.com/gluesql/gluesql/pull/1107))\\n- Remove `Rc` in `validate.rs` [@ever0de](https://github.com/ever0de) ([#1106](https://github.com/gluesql/gluesql/pull/1106))\\n- Remove `Error::Storage` variant [@ever0de](https://github.com/ever0de) ([#1105](https://github.com/gluesql/gluesql/pull/1105))\\n- Replace `Box::pin` to `futures_enum::Stream` [@ever0de](https://github.com/ever0de) ([#1103](https://github.com/gluesql/gluesql/pull/1103))\\n- Remove stream unneeded map ok uses [@panarch](https://github.com/panarch) ([#1104](https://github.com/gluesql/gluesql/pull/1104))\\n- Replace `TryStream` to `Stream` [@ever0de](https://github.com/ever0de) ([#1102](https://github.com/gluesql/gluesql/pull/1102))\\n- Remove `Rc` from `ColumnValidation` [@ever0de](https://github.com/ever0de) ([#1101](https://github.com/gluesql/gluesql/pull/1101))\\n- Remove unneeded Rc uses in fetch\\\\_labels [@panarch](https://github.com/panarch) ([#1098](https://github.com/gluesql/gluesql/pull/1098))\\n- Simplify TryStreamExt using codes in join executor, [@panarch](https://github.com/panarch) ([#1097](https://github.com/gluesql/gluesql/pull/1097))\\n- Fix typo in plan/validate.rs [@ever0de](https://github.com/ever0de) ([#1093](https://github.com/gluesql/gluesql/pull/1093))\\n- Update IdbStorage to use Schema::{to\\\\_ddl, from\\\\_ddl} to manage schema \u2026 [@panarch](https://github.com/panarch) ([#1090](https://github.com/gluesql/gluesql/pull/1090))\\n- Update Cargo.toml files to inherit workspace level configs, [@panarch](https://github.com/panarch) ([#1088](https://github.com/gluesql/gluesql/pull/1088))\\n- Add Error enum to core::prelude [@panarch](https://github.com/panarch) ([#1087](https://github.com/gluesql/gluesql/pull/1087))\\n- Update `StringExt` implementation to use `str` [@ever0de](https://github.com/ever0de) ([#1082](https://github.com/gluesql/gluesql/pull/1082))\\n- Add enum `StrSlice` under enum `Evaluated` [@zmrdltl](https://github.com/zmrdltl) ([#999](https://github.com/gluesql/gluesql/pull/999))\\n- refactor plan::validate::Context.labels from String to str [@devgony](https://github.com/devgony) ([#1079](https://github.com/gluesql/gluesql/pull/1079))\\n- Replace `dyn object` to generic [@ever0de](https://github.com/ever0de) ([#1075](https://github.com/gluesql/gluesql/pull/1075))\\n- Implement ValidationContext(schema\\\\_map + alias) to enhance validation of ambiguous columns [@devgony](https://github.com/devgony) ([#883](https://github.com/gluesql/gluesql/pull/883))\\n- Remove `clone` in `check_table_factor` [@ever0de](https://github.com/ever0de) ([#1058](https://github.com/gluesql/gluesql/pull/1058))\\n- Bump rust-toolchain version to `1.66` [@ever0de](https://github.com/ever0de) ([#1057](https://github.com/gluesql/gluesql/pull/1057))\\n- Bump `sqlparser` version to `0.30` [@ever0de](https://github.com/ever0de) ([#1056](https://github.com/gluesql/gluesql/pull/1056))\\n- Replace `Box::pin` to `futures_enum` in aggregate module [@ever0de](https://github.com/ever0de) ([#1055](https://github.com/gluesql/gluesql/pull/1055))\\n- Update js/ Cargo.toml to use gloo-utils for serde handling [@panarch](https://github.com/panarch) ([#1049](https://github.com/gluesql/gluesql/pull/1049))\\n- Remove ast::ColumnOption and merge UNIQUE option to ColumnDef [@panarch](https://github.com/panarch) ([#1044](https://github.com/gluesql/gluesql/pull/1044))\\n- Rewrite \\\\& simplify plan/context.rs codes, [@panarch](https://github.com/panarch) ([#1045](https://github.com/gluesql/gluesql/pull/1045))\\n- Move ast::ColumnOption::Default variant to ColumnDef [@panarch](https://github.com/panarch) ([#1042](https://github.com/gluesql/gluesql/pull/1042))\\n- [AST-Builder] Remove unused prebuild nodes  [@ding-young](https://github.com/ding-young) ([#1043](https://github.com/gluesql/gluesql/pull/1043))\\n- Remove data::RowError, [@panarch](https://github.com/panarch) ([#1040](https://github.com/gluesql/gluesql/pull/1040))\\n- Reorder project in ASTBuilder (project -> ordery\\\\_by -> limit,offset) [@devgony](https://github.com/devgony) ([#1039](https://github.com/gluesql/gluesql/pull/1039))\\n- Remove unused LimitOffsetNode in AST builder [@panarch](https://github.com/panarch) ([#1038](https://github.com/gluesql/gluesql/pull/1038))\\n- Rename executor/ blend.rs module to project.rs [@SaumyaBhushan](https://github.com/SaumyaBhushan) ([#1036](https://github.com/gluesql/gluesql/pull/1036))\\n- Add Debug to AST builder nodes [@panarch](https://github.com/panarch) ([#1022](https://github.com/gluesql/gluesql/pull/1022))\\n- Bump rust toolchain version to 1.65 [@ever0de](https://github.com/ever0de) ([#1035](https://github.com/gluesql/gluesql/pull/1035))\\n- Remove `Content::Shared` variant in executor/ `RowContext` [@ever0de](https://github.com/ever0de) ([#1032](https://github.com/gluesql/gluesql/pull/1032))\\n- Merge insert logics in row.rs \\\\& execute.rs into executor/insert.rs [@panarch](https://github.com/panarch) ([#1031](https://github.com/gluesql/gluesql/pull/1031))\\n- Merge FilterContext and BlendContext into RowContext [@panarch](https://github.com/panarch) ([#1029](https://github.com/gluesql/gluesql/pull/1029))\\n- Update `data::Row` to contain columns [@panarch](https://github.com/panarch) ([#1026](https://github.com/gluesql/gluesql/pull/1026))\\n- Add LIST type support in CONCAT function [@seonghun-dev](https://github.com/seonghun-dev) ([#1021](https://github.com/gluesql/gluesql/pull/1021))\\n- Remove LimitOffsetNode in AST builder [@panarch](https://github.com/panarch) ([#1023](https://github.com/gluesql/gluesql/pull/1023))\\n- Fix typo [@ever0de](https://github.com/ever0de) ([#1020](https://github.com/gluesql/gluesql/pull/1020))\\n- Add NumericNode to handle numeric value inputs in AST builder [@panarch](https://github.com/panarch) ([#1017](https://github.com/gluesql/gluesql/pull/1017))\\n- Update ValueError::InvalidJsonString error to show input text [@panarch](https://github.com/panarch) ([#1018](https://github.com/gluesql/gluesql/pull/1018))\\n- Add null() func which makes NULL value in AST builder [@panarch](https://github.com/panarch) ([#1016](https://github.com/gluesql/gluesql/pull/1016))\\n- Add --all-targets option to cargo clippy rust gh-action [@panarch](https://github.com/panarch) ([#1015](https://github.com/gluesql/gluesql/pull/1015))\\n- Move import `ColumnOption` used only by `alter-table` feature in ast-builder [@ever0de](https://github.com/ever0de) ([#1014](https://github.com/gluesql/gluesql/pull/1014))\\n- Add value/ binary\\\\_op `Parital{Ord,Cmp}` impl macro [@ever0de](https://github.com/ever0de) ([#1013](https://github.com/gluesql/gluesql/pull/1013))\\n- Change to use internal chrono errors in parsing datetime [@ever0de](https://github.com/ever0de) ([#1010](https://github.com/gluesql/gluesql/pull/1010))\\n- Resolve unreachable branch of `Value::position` [@ever0de](https://github.com/ever0de) ([#1012](https://github.com/gluesql/gluesql/pull/1012))\\n- Apply binary\\\\_op macros to existing data types [@ChobobDev](https://github.com/ChobobDev) ([#987](https://github.com/gluesql/gluesql/pull/987))\\n- chore: Use rust-cache action to cache dependencies [@jongwooo](https://github.com/jongwooo) ([#1006](https://github.com/gluesql/gluesql/pull/1006))\\n- Group the import statements [@yugeeklab](https://github.com/yugeeklab) ([#1005](https://github.com/gluesql/gluesql/pull/1005))\\n- Make Tester::new async [@ShaddyDC](https://github.com/ShaddyDC) ([#1004](https://github.com/gluesql/gluesql/pull/1004))\\n- Make MemoryStorage Store trait features optional, [@panarch](https://github.com/panarch) ([#1003](https://github.com/gluesql/gluesql/pull/1003))\\n- Replace `double quotes` to `identifier` [@devgony](https://github.com/devgony) ([#1001](https://github.com/gluesql/gluesql/pull/1001))\\n- Change chrono `from_*` methods to `from_*_opt` [@ever0de](https://github.com/ever0de) ([#1000](https://github.com/gluesql/gluesql/pull/1000))\\n- Improve duplicate column names validation [@devgony](https://github.com/devgony) ([#995](https://github.com/gluesql/gluesql/pull/995))\\n- Register `lock` when `fetch_all_schemas` face `idle` [@devgony](https://github.com/devgony) ([#996](https://github.com/gluesql/gluesql/pull/996))\\n- Merge ColumnOption::{Null, NotNull} into a single option [@devgony](https://github.com/devgony) ([#986](https://github.com/gluesql/gluesql/pull/986))\\n- Update rust.yml github action to test examples/ [@panarch](https://github.com/panarch) ([#994](https://github.com/gluesql/gluesql/pull/994))\\n\\n\\n## \ud83c\udf33 Documentation\\n\\n**We now provide an official documentation website at https://gluesql.org/docs**\\n\\n- Add documentation for CLI [@devgony](https://github.com/devgony) ([#1183](https://github.com/gluesql/gluesql/pull/1183))\\n- Add ast\\\\_builder null handling doc [@LEE026](https://github.com/LEE026) ([#1209](https://github.com/gluesql/gluesql/pull/1209))\\n- Add document of datetime current date and time for ast-builder [@heewoneha](https://github.com/heewoneha) ([#1208](https://github.com/gluesql/gluesql/pull/1208))\\n- docs: write position and indexing docs [@Bangseungjae](https://github.com/Bangseungjae) ([#1206](https://github.com/gluesql/gluesql/pull/1206))\\n- Add docs/formatting for ast\\\\_builder [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1200](https://github.com/gluesql/gluesql/pull/1200))\\n- Update math basic arithmetic docs for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1202](https://github.com/gluesql/gluesql/pull/1202))\\n- Add pattern-matching doc for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1199](https://github.com/gluesql/gluesql/pull/1199))\\n- Add ast builder Trimming function docs [@Bangseungjae](https://github.com/Bangseungjae) ([#1197](https://github.com/gluesql/gluesql/pull/1197))\\n- Add doc about the function Date \\\\& Time Conversion [@heewoneha](https://github.com/heewoneha) ([#1196](https://github.com/gluesql/gluesql/pull/1196))\\n- add Docs/case conversion(upper, lower, InitCap) in ast builder [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1195](https://github.com/gluesql/gluesql/pull/1195))\\n- Add math conversion docs for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1192](https://github.com/gluesql/gluesql/pull/1192))\\n- Added documentation for the round, ceil, and floor functions in ast-builder [@LEE026](https://github.com/LEE026) ([#1191](https://github.com/gluesql/gluesql/pull/1191))\\n- Add  documentation layout for AstBuilder [@devgony](https://github.com/devgony) ([#1184](https://github.com/gluesql/gluesql/pull/1184))\\n- Add documentation for Json Storage [@devgony](https://github.com/devgony) ([#1170](https://github.com/gluesql/gluesql/pull/1170))\\n- Add documentation for math functions [@panarch](https://github.com/panarch) ([#1173](https://github.com/gluesql/gluesql/pull/1173))\\n- Add doc for datetime, geometry, list \\\\& map and other functions, [@panarch](https://github.com/panarch) ([#1172](https://github.com/gluesql/gluesql/pull/1172))\\n- Add documentation for text functions in SQL [@panarch](https://github.com/panarch) ([#1167](https://github.com/gluesql/gluesql/pull/1167))\\n- Write docs/ Supported Storages section contents, [@panarch](https://github.com/panarch) ([#1165](https://github.com/gluesql/gluesql/pull/1165))\\n- Add SQL function list with categories to docs/ [@panarch](https://github.com/panarch) ([#1166](https://github.com/gluesql/gluesql/pull/1166))\\n- Write docs/getting-started/javascript-web.md [@panarch](https://github.com/panarch) ([#1159](https://github.com/gluesql/gluesql/pull/1159))\\n- Write docs/ Developing Custom Storages contents [@panarch](https://github.com/panarch) ([#1155](https://github.com/gluesql/gluesql/pull/1155))\\n- docs: add newly added data type into README.md [@ChobobDev](https://github.com/ChobobDev) ([#1137](https://github.com/gluesql/gluesql/pull/1137))\\n- docs(readme): add discord icon to chat badge [@LeoDog896](https://github.com/LeoDog896) ([#1122](https://github.com/gluesql/gluesql/pull/1122))\\n- docs(javascript): update examples link [@LeoDog896](https://github.com/LeoDog896) ([#1108](https://github.com/gluesql/gluesql/pull/1108))\\n\\n### Docs - setup\\n\\n- Add gh-action for docs build - runs on both push \\\\& pr [@panarch](https://github.com/panarch) ([#1215](https://github.com/gluesql/gluesql/pull/1215))\\n- Setup blog based on docusaurus, [@panarch](https://github.com/panarch) ([#1212](https://github.com/gluesql/gluesql/pull/1212))\\n- Remove mdbook which is replaced by docs/ (docusaurus based) [@panarch](https://github.com/panarch) ([#1164](https://github.com/gluesql/gluesql/pull/1164))\\n- Add docusaurus deployment github action setup [@panarch](https://github.com/panarch) ([#1163](https://github.com/gluesql/gluesql/pull/1163))\\n- Update coverage, javascript and rust gh action to ignore `docs/**` pa\u2026 [@panarch](https://github.com/panarch) ([#1168](https://github.com/gluesql/gluesql/pull/1168))\\n- Update docs/ global styles, [@panarch](https://github.com/panarch) ([#1156](https://github.com/gluesql/gluesql/pull/1156))\\n- Setup new documentation based on docusaurus [@panarch](https://github.com/panarch) ([#1136](https://github.com/gluesql/gluesql/pull/1136))\\n\\n\\n## \ud83d\udccb Tests\\n\\n- Add ifnull test suite for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1207](https://github.com/gluesql/gluesql/pull/1207))\\n- Add datetime current date and time test case for ast builder [@heewoneha](https://github.com/heewoneha) ([#1205](https://github.com/gluesql/gluesql/pull/1205))\\n- Add Position and Indexing test code [@Bangseungjae](https://github.com/Bangseungjae) ([#1203](https://github.com/gluesql/gluesql/pull/1203))\\n- Add math basic arithmetic test case for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1201](https://github.com/gluesql/gluesql/pull/1201))\\n- Add testcase/formatting for ast\\\\_builder [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1198](https://github.com/gluesql/gluesql/pull/1198))\\n- Add pattern\\\\_matching test cases for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1194](https://github.com/gluesql/gluesql/pull/1194))\\n- Add test code function / text / trimming [@Bangseungjae](https://github.com/Bangseungjae) ([#1190](https://github.com/gluesql/gluesql/pull/1190))\\n- Add Testcase/case conversion [@sooyeonyim-t](https://github.com/sooyeonyim-t) ([#1193](https://github.com/gluesql/gluesql/pull/1193))\\n- Add datetime conversion test cases for ast\\\\_builder [@heewoneha](https://github.com/heewoneha) ([#1187](https://github.com/gluesql/gluesql/pull/1187))\\n- Add math conversion test case for ast\\\\_builder [@changi1122](https://github.com/changi1122) ([#1189](https://github.com/gluesql/gluesql/pull/1189))\\n- Add rounding test cases for ast\\\\_builder [@LEE026](https://github.com/LEE026) ([#1186](https://github.com/gluesql/gluesql/pull/1186))\\n- Update delete and insert tests in test-suite/, [@panarch](https://github.com/panarch) ([#1180](https://github.com/gluesql/gluesql/pull/1180))\\n- Remove gen-\\\\_transaction\\\\_dictionary\\\\_tests! in test-suite, [@panarch](https://github.com/panarch) ([#1179](https://github.com/gluesql/gluesql/pull/1179))\\n- Refactor geometry function tests in test-suite, [@panarch](https://github.com/panarch) ([#1176](https://github.com/gluesql/gluesql/pull/1176))\\n- Refactor SQL function tests in test-suite, [@panarch](https://github.com/panarch) ([#1174](https://github.com/gluesql/gluesql/pull/1174))\\n- fix : fix missing intg test for new data type [@ChobobDev](https://github.com/ChobobDev) ([#1143](https://github.com/gluesql/gluesql/pull/1143))\\n- Add unit tests for `TryFrom<&Value> for Decimal` [@ChobobDev](https://github.com/ChobobDev) ([#1139](https://github.com/gluesql/gluesql/pull/1139))\\n- Add \\"cli\\" unittest [@pythonbrad](https://github.com/pythonbrad) ([#1094](https://github.com/gluesql/gluesql/pull/1094))\\n- Add `core/data` module unit tests [@pythonbrad](https://github.com/pythonbrad) ([#1092](https://github.com/gluesql/gluesql/pull/1092))\\n\\n## \ud83d\udc1b Bug Fixes\\n\\n- Fix docusaurus pages/index broken link [@panarch](https://github.com/panarch) ([#1214](https://github.com/gluesql/gluesql/pull/1214))\\n- Fix docs/ Discord GlueSQL channel invite link address [@panarch](https://github.com/panarch) ([#1213](https://github.com/gluesql/gluesql/pull/1213))\\n- Fix InvalidJsonString error message replacing payload to fileName [@devgony](https://github.com/devgony) ([#1185](https://github.com/gluesql/gluesql/pull/1185))\\n- Fix TryFrom `Value::Str` to `u128` not to use `parse_uuid` [@ChobobDev](https://github.com/ChobobDev) ([#1134](https://github.com/gluesql/gluesql/pull/1134))\\n- Fix column alias with identifer for `TableFactor::Derived` [@ding-young](https://github.com/ding-young) ([#1119](https://github.com/gluesql/gluesql/pull/1119))\\n- Pass data even when `deleted_by` is not present [@ever0de](https://github.com/ever0de) ([#1117](https://github.com/gluesql/gluesql/pull/1117))\\n- Fix MemoryStorage \\\\& WebStorage primary key support [@panarch](https://github.com/panarch) ([#1115](https://github.com/gluesql/gluesql/pull/1115))\\n- Fix `plan::validate` to handle `CTAS` and `ITAS` adding unit test [@devgony](https://github.com/devgony) ([#1074](https://github.com/gluesql/gluesql/pull/1074))\\n- Fix test-suite tester functions to show (found, expected) shape [@panarch](https://github.com/panarch) ([#1028](https://github.com/gluesql/gluesql/pull/1028))"}]}')}}]);