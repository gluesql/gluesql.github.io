"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[53],{1109:t=>{t.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Create a Page","href":"/docs/canary/docs/tutorial-basics/create-a-page","docId":"tutorial-basics/create-a-page"},{"type":"link","label":"Create a Document","href":"/docs/canary/docs/tutorial-basics/create-a-document","docId":"tutorial-basics/create-a-document"},{"type":"link","label":"Create a Blog Post","href":"/docs/canary/docs/tutorial-basics/create-a-blog-post","docId":"tutorial-basics/create-a-blog-post"},{"type":"link","label":"Markdown Features","href":"/docs/canary/docs/tutorial-basics/markdown-features","docId":"tutorial-basics/markdown-features"},{"type":"link","label":"Deploy your site","href":"/docs/canary/docs/tutorial-basics/deploy-your-site","docId":"tutorial-basics/deploy-your-site"},{"type":"link","label":"Congratulations!","href":"/docs/canary/docs/tutorial-basics/congratulations","docId":"tutorial-basics/congratulations"}],"gettingStartedSidebar":[{"type":"link","label":"Rust","href":"/docs/canary/docs/getting-started/rust","docId":"getting-started/rust"},{"type":"link","label":"JavaScript (Web Browser)","href":"/docs/canary/docs/getting-started/javascript-web","docId":"getting-started/javascript-web"},{"type":"link","label":"Node.js","href":"/docs/canary/docs/getting-started/nodejs","docId":"getting-started/nodejs"},{"type":"link","label":"Command-Line Interface","href":"/docs/canary/docs/getting-started/cli","docId":"getting-started/cli"}],"sqlSyntaxSidebar":[{"type":"link","label":"Introduction","href":"/docs/canary/docs/sql-syntax/intro","docId":"sql-syntax/intro"},{"type":"category","label":"Statements","collapsible":true,"collapsed":false,"items":[{"type":"category","label":"Querying","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"WHERE","href":"/docs/canary/docs/sql-syntax/statements/querying/where","docId":"sql-syntax/statements/querying/where"},{"type":"link","label":"JOIN","href":"/docs/canary/docs/sql-syntax/statements/querying/join","docId":"sql-syntax/statements/querying/join"},{"type":"link","label":"LIMIT & OFFSET","href":"/docs/canary/docs/sql-syntax/statements/querying/limit","docId":"sql-syntax/statements/querying/limit"},{"type":"link","label":"Aggregation","href":"/docs/canary/docs/sql-syntax/statements/querying/aggregation","docId":"sql-syntax/statements/querying/aggregation"},{"type":"link","label":"Schemaless Data","href":"/docs/canary/docs/sql-syntax/statements/querying/schemaless","docId":"sql-syntax/statements/querying/schemaless"}]},{"type":"category","label":"Data definition","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"CREATE TABLE","href":"/docs/canary/docs/sql-syntax/statements/data-definition/create-table","docId":"sql-syntax/statements/data-definition/create-table"},{"type":"link","label":"DROP TABLE","href":"/docs/canary/docs/sql-syntax/statements/data-definition/drop-table","docId":"sql-syntax/statements/data-definition/drop-table"},{"type":"link","label":"CREATE INDEX","href":"/docs/canary/docs/sql-syntax/statements/data-definition/create-index","docId":"sql-syntax/statements/data-definition/create-index"},{"type":"link","label":"DROP INDEX","href":"/docs/canary/docs/sql-syntax/statements/data-definition/drop-index","docId":"sql-syntax/statements/data-definition/drop-index"},{"type":"link","label":"ALTER TABLE","href":"/docs/canary/docs/sql-syntax/statements/data-definition/alter-table","docId":"sql-syntax/statements/data-definition/alter-table"}]},{"type":"category","label":"Data manipulation","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"INSERT","href":"/docs/canary/docs/sql-syntax/statements/data-manipulation/insert","docId":"sql-syntax/statements/data-manipulation/insert"},{"type":"link","label":"UPDATE","href":"/docs/canary/docs/sql-syntax/statements/data-manipulation/update","docId":"sql-syntax/statements/data-manipulation/update"},{"type":"link","label":"DELETE","href":"/docs/canary/docs/sql-syntax/statements/data-manipulation/delete","docId":"sql-syntax/statements/data-manipulation/delete"}]},{"type":"link","label":"Transaction","href":"/docs/canary/docs/sql-syntax/statements/transaction","docId":"sql-syntax/statements/transaction"},{"type":"category","label":"Metadata","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"SHOW TABLES","href":"/docs/canary/docs/sql-syntax/statements/metadata/show-tables","docId":"sql-syntax/statements/metadata/show-tables"},{"type":"link","label":"Data Dictionary","href":"/docs/canary/docs/sql-syntax/statements/metadata/data-dictionary","docId":"sql-syntax/statements/metadata/data-dictionary"}]}]},{"type":"category","label":"Data types","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"BOOLEAN","href":"/docs/canary/docs/sql-syntax/data-types/boolean","docId":"sql-syntax/data-types/boolean"},{"type":"link","label":"Integer Types","href":"/docs/canary/docs/sql-syntax/data-types/integers","docId":"sql-syntax/data-types/integers"},{"type":"link","label":"FLOAT","href":"/docs/canary/docs/sql-syntax/data-types/float","docId":"sql-syntax/data-types/float"},{"type":"link","label":"TEXT","href":"/docs/canary/docs/sql-syntax/data-types/text","docId":"sql-syntax/data-types/text"},{"type":"link","label":"DECIMAL","href":"/docs/canary/docs/sql-syntax/data-types/decimal","docId":"sql-syntax/data-types/decimal"},{"type":"link","label":"DATE","href":"/docs/canary/docs/sql-syntax/data-types/date","docId":"sql-syntax/data-types/date"},{"type":"link","label":"TIMESTAMP","href":"/docs/canary/docs/sql-syntax/data-types/timestamp","docId":"sql-syntax/data-types/timestamp"},{"type":"link","label":"TIME","href":"/docs/canary/docs/sql-syntax/data-types/time","docId":"sql-syntax/data-types/time"},{"type":"link","label":"INTERVAL","href":"/docs/canary/docs/sql-syntax/data-types/interval","docId":"sql-syntax/data-types/interval"},{"type":"link","label":"LIST","href":"/docs/canary/docs/sql-syntax/data-types/list","docId":"sql-syntax/data-types/list"},{"type":"link","label":"MAP","href":"/docs/canary/docs/sql-syntax/data-types/map","docId":"sql-syntax/data-types/map"},{"type":"link","label":"BYTEA","href":"/docs/canary/docs/sql-syntax/data-types/bytea","docId":"sql-syntax/data-types/bytea"},{"type":"link","label":"INET","href":"/docs/canary/docs/sql-syntax/data-types/inet","docId":"sql-syntax/data-types/inet"},{"type":"link","label":"UUID","href":"/docs/canary/docs/sql-syntax/data-types/uuid","docId":"sql-syntax/data-types/uuid"}],"href":"/docs/canary/docs/category/data-types"}],"astBuilderSidebar":[{"type":"link","label":"Introduction","href":"/docs/canary/docs/ast-builder/intro","docId":"ast-builder/intro"},{"type":"category","label":"Querying Data","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Fetching Data from Storage","href":"/docs/canary/docs/ast-builder/querying-data/fetching-data-from-storage","docId":"ast-builder/querying-data/fetching-data-from-storage"},{"type":"link","label":"Using Preloaded Data","href":"/docs/canary/docs/ast-builder/querying-data/using-preloaded-data","docId":"ast-builder/querying-data/using-preloaded-data"},{"type":"link","label":"Creating Derived Subqueries","href":"/docs/canary/docs/ast-builder/querying-data/creating-derived-subqueries","docId":"ast-builder/querying-data/creating-derived-subqueries"}]},{"type":"link","label":"Inserting Data","href":"/docs/canary/docs/ast-builder/inserting-data","docId":"ast-builder/inserting-data"},{"type":"link","label":"Updating Data","href":"/docs/canary/docs/ast-builder/updating-data","docId":"ast-builder/updating-data"},{"type":"link","label":"Deleting Data","href":"/docs/canary/docs/ast-builder/deleting-data","docId":"ast-builder/deleting-data"}],"customStorageSidebar":[{"type":"link","label":"Introduction","href":"/docs/canary/docs/storages/intro","docId":"storages/intro"},{"type":"category","label":"Supported Storages","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Memory Storage","href":"/docs/canary/docs/storages/supported-storages/memory-storage","docId":"storages/supported-storages/memory-storage"},{"type":"link","label":"Shared Memory Storage","href":"/docs/canary/docs/storages/supported-storages/shared-memory-storage","docId":"storages/supported-storages/shared-memory-storage"},{"type":"link","label":"Sled Storage","href":"/docs/canary/docs/storages/supported-storages/sled-storage","docId":"storages/supported-storages/sled-storage"},{"type":"link","label":"JSON Storage","href":"/docs/canary/docs/storages/supported-storages/json-storage","docId":"storages/supported-storages/json-storage"},{"type":"link","label":"Web Storage (local & session)","href":"/docs/canary/docs/storages/supported-storages/web-storage","docId":"storages/supported-storages/web-storage"},{"type":"link","label":"IndexedDB Storage","href":"/docs/canary/docs/storages/supported-storages/idb-storage","docId":"storages/supported-storages/idb-storage"}]},{"type":"category","label":"Developing Custom Storages","collapsible":true,"collapsed":false,"items":[{"type":"link","label":"Introduction","href":"/docs/canary/docs/storages/developing-custom-storages/intro","docId":"storages/developing-custom-storages/intro"},{"type":"category","label":"Understanding Store traits","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Store","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/store","docId":"storages/developing-custom-storages/store-traits/store"},{"type":"link","label":"StoreMut","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/store-mut","docId":"storages/developing-custom-storages/store-traits/store-mut"},{"type":"link","label":"AlterTable","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/alter-table","docId":"storages/developing-custom-storages/store-traits/alter-table"},{"type":"link","label":"Transaction","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/transaction","docId":"storages/developing-custom-storages/store-traits/transaction"},{"type":"link","label":"CustomFunction","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/custom-function","docId":"storages/developing-custom-storages/store-traits/custom-function"},{"type":"link","label":"CustomFunctionMut","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/custom-function-mut","docId":"storages/developing-custom-storages/store-traits/custom-function-mut"},{"type":"link","label":"Index","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/index-trait","docId":"storages/developing-custom-storages/store-traits/index-trait"},{"type":"link","label":"IndexMut","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/index-mut","docId":"storages/developing-custom-storages/store-traits/index-mut"},{"type":"link","label":"Metadata","href":"/docs/canary/docs/storages/developing-custom-storages/store-traits/metadata","docId":"storages/developing-custom-storages/store-traits/metadata"}]},{"type":"link","label":"Using the Test Suite","href":"/docs/canary/docs/storages/developing-custom-storages/using-test-suite","docId":"storages/developing-custom-storages/using-test-suite"}]}]},"docs":{"ast-builder/deleting-data":{"id":"ast-builder/deleting-data","title":"Deleting Data","description":"In this section, we will discuss how to delete data from a table using GlueSQL.","sidebar":"astBuilderSidebar"},"ast-builder/inserting-data":{"id":"ast-builder/inserting-data","title":"Inserting Data","description":"In this section, we will discuss how to insert data into a table using GlueSQL.","sidebar":"astBuilderSidebar"},"ast-builder/intro":{"id":"ast-builder/intro","title":"Introduction","description":"GlueSQL offers two ways to create and execute queries: using SQL statements or using the AST Builder. In this introductory page, we will focus on the AST Builder.","sidebar":"astBuilderSidebar"},"ast-builder/querying-data/creating-derived-subqueries":{"id":"ast-builder/querying-data/creating-derived-subqueries","title":"Creating Derived Subqueries","description":"This document covers the aliasas functionality of the AST Builder in the GlueSQL project. The aliasas method allows you to create a derived subquery, which is similar to subqueries in SQL. It gives you the ability to use the output of a query as a table to perform further queries.","sidebar":"astBuilderSidebar"},"ast-builder/querying-data/fetching-data-from-storage":{"id":"ast-builder/querying-data/fetching-data-from-storage","title":"Fetching Data from Storage","description":"The AST Builder provides a powerful and flexible way to query data from your tables, similar to SQL\'s SELECT statement. This guide will show you how to use the AST Builder\'s table(\\"foo\\").select() method to perform various query types, including filtering, joining, grouping, ordering, and pagination.","sidebar":"astBuilderSidebar"},"ast-builder/querying-data/using-preloaded-data":{"id":"ast-builder/querying-data/using-preloaded-data","title":"Using Preloaded Data","description":"This guide will show you how to use AST Builder to query data that has already been loaded into memory, as opposed to querying data from storage. This is similar to SQL\'s VALUES functionality.","sidebar":"astBuilderSidebar"},"ast-builder/updating-data":{"id":"ast-builder/updating-data","title":"Updating Data","description":"In this section, we will discuss how to update data in a table using GlueSQL.","sidebar":"astBuilderSidebar"},"getting-started/cli":{"id":"getting-started/cli","title":"Command-Line Interface","description":"","sidebar":"gettingStartedSidebar"},"getting-started/javascript-web":{"id":"getting-started/javascript-web","title":"JavaScript (Web Browser)","description":"GlueSQL is a SQL database engine written in Rust, compiled to WebAssembly, and can be used in JavaScript. This guide will walk you through the process of installing and using the GlueSQL package.","sidebar":"gettingStartedSidebar"},"getting-started/nodejs":{"id":"getting-started/nodejs","title":"Node.js","description":"This guide will help you get started with GlueSQL in a Node.js project. First, install the gluesql package using npm by running the following command in your terminal:","sidebar":"gettingStartedSidebar"},"getting-started/rust":{"id":"getting-started/rust","title":"Rust","description":"To install and use GlueSQL in your Rust project, you\'ll first need to add it as a dependency from crates.io. You can do this by adding the following lines to your Cargo.toml file:","sidebar":"gettingStartedSidebar"},"intro":{"id":"intro","title":"Tutorial Intro","description":"Let\'s discover Docusaurus in less than 5 minutes."},"sql-syntax/data-types/boolean":{"id":"sql-syntax/data-types/boolean","title":"BOOLEAN","description":"The BOOLEAN data type in SQL is used to store boolean values, which can be either TRUE or FALSE. This data type is useful for representing binary states or conditions in your data.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/bytea":{"id":"sql-syntax/data-types/bytea","title":"BYTEA","description":"The BYTEA data type in SQL is used to store binary data, such as images, audio files, or any other type of data that needs to be stored in its raw form. In GlueSQL, the BYTEA data type is represented as a sequence of bytes.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/date":{"id":"sql-syntax/data-types/date","title":"DATE","description":"In GlueSQL, the DATE data type is used to store date values in the format \'YYYY-MM-DD\'. Note that GlueSQL currently does not support timezones.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/decimal":{"id":"sql-syntax/data-types/decimal","title":"DECIMAL","description":"The DECIMAL data type in SQL is used to store exact numeric values, making it suitable for financial calculations and other operations requiring a high level of precision without round-off errors. In GlueSQL, the DECIMAL data type is implemented using a pure Rust library, providing a 96-bit integer number, a scaling factor for specifying the decimal fraction, and a 1-bit sign.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/float":{"id":"sql-syntax/data-types/float","title":"FLOAT","description":"The FLOAT data type in SQL is used to store floating-point numbers. In GlueSQL, the FLOAT data type represents a 64-bit floating-point number, providing the ability to store numbers with decimal values and a wide range of magnitude.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/inet":{"id":"sql-syntax/data-types/inet","title":"INET","description":"The INET data type in SQL is used to store IPv4 and IPv6 addresses. These addresses can be compared, filtered, and sorted using standard SQL operations.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/integers":{"id":"sql-syntax/data-types/integers","title":"Integer Types","description":"GlueSQL supports the following integer data types:","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/interval":{"id":"sql-syntax/data-types/interval","title":"INTERVAL","description":"The INTERVAL data type in GlueSQL is used to represent a period of time. In accordance with the ANSI SQL standard, several subtypes of INTERVAL can be used to represent different units of time, such as years, months, days, hours, minutes, and seconds. These subtypes are:","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/list":{"id":"sql-syntax/data-types/list","title":"LIST","description":"The LIST data type in GlueSQL is used to store ordered collections of elements, similar to JSON arrays. The elements can be any valid data supported by GlueSQL, such as numbers, strings, booleans, null, MAP, or even other nested LIST values. Although the input is provided in a JSON array format for convenience, it can store more than just JSON data.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/map":{"id":"sql-syntax/data-types/map","title":"MAP","description":"The MAP data type in GlueSQL is used to store nested key-value pairs, similar to JSON objects. The object keys must be strings, and the values can be any valid data supported by GlueSQL, such as numbers, strings, booleans, null, or even other nested MAP values. Although the input is provided in a JSON object format for convenience, it can store more than just JSON data.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/text":{"id":"sql-syntax/data-types/text","title":"TEXT","description":"The TEXT data type in SQL is used to store variable-length character strings. In GlueSQL, the TEXT data type is the only supported string data type, providing the ability to store and manage strings of varying lengths.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/time":{"id":"sql-syntax/data-types/time","title":"TIME","description":"In GlueSQL, the TIME data type is used to store time values in the format \'HHSS.SSS\'. The code snippet provided demonstrates how to create a table with TIME columns, insert data into it, and perform various queries and operations on the data.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/timestamp":{"id":"sql-syntax/data-types/timestamp","title":"TIMESTAMP","description":"In GlueSQL, the TIMESTAMP data type is used to store date and time values in the format \'YYYY-MM-DD HHSS.SSSS\'. Although timezone information can be included in the input string, GlueSQL stores all TIMESTAMP values in UTC, discarding the timezone information.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/data-types/uuid":{"id":"sql-syntax/data-types/uuid","title":"UUID","description":"The UUID data type in SQL is used to store universally unique identifiers (UUIDs). These identifiers can be compared, filtered, and sorted using standard SQL operations.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/intro":{"id":"sql-syntax/intro","title":"Introduction","description":"Welcome to the Introduction page for the SQL Syntax category in GlueSQL! In this section, we\'ll provide a brief overview of the SQL syntax supported by GlueSQL. You can find more in-depth examples and details by browsing the other pages in this category.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-definition/alter-table":{"id":"sql-syntax/statements/data-definition/alter-table","title":"ALTER TABLE","description":"The ALTER TABLE statement is an SQL command used to modify the structure of an existing table in a database. This operation is useful when you need to add, remove, or modify columns or constraints in a table. In this document, we\'ll explain the syntax and usage of the ALTER TABLE statement, including the RENAME, ADD COLUMN, and DROP COLUMN clauses.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-definition/create-index":{"id":"sql-syntax/statements/data-definition/create-index","title":"CREATE INDEX","description":"CREATE INDEX statement is used to create an index on one or more columns of a table. Indexes can improve query performance by allowing the database to quickly locate rows with specific column values. They can also be used with the ORDER BY clause to improve sorting performance. An index can be thought of as a data structure that maps the values of a specific column or columns to the corresponding rows in a table. This mapping allows the database to perform lookups and sorting operations more efficiently, as it does not have to scan the entire table.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-definition/create-table":{"id":"sql-syntax/statements/data-definition/create-table","title":"CREATE TABLE","description":"The CREATE TABLE statement is a fundamental SQL command used to create a new table in a database. Tables are the primary structure in databases, as they hold the data organized in rows and columns. In this document, we\'ll explain the syntax and usage of the CREATE TABLE statement, including the IF NOT EXISTS clause.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-definition/drop-index":{"id":"sql-syntax/statements/data-definition/drop-index","title":"DROP INDEX","description":"DROP INDEX statement is used to remove an existing index from a table. This can be useful when an index is no longer needed, or if you want to free up storage space and reduce maintenance overhead associated with maintaining the index.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-definition/drop-table":{"id":"sql-syntax/statements/data-definition/drop-table","title":"DROP TABLE","description":"The DROP TABLE statement is an SQL command used to remove one or more tables from a database. This operation is useful when you no longer need a table or want to clear out old data structures. In this document, we\'ll explain the syntax and usage of the DROP TABLE statement, including the IF EXISTS clause and dropping multiple tables at once.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-manipulation/delete":{"id":"sql-syntax/statements/data-manipulation/delete","title":"DELETE","description":"The DELETE statement is used to remove records from a table. You can delete a single row, multiple rows, or all rows at once based on specific conditions.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-manipulation/insert":{"id":"sql-syntax/statements/data-manipulation/insert","title":"INSERT","description":"The INSERT statement is used to insert new records into a table. You can insert a single row or multiple rows at once, and you can also use the NULL, NOT NULL, and DEFAULT constraints to define how values are inserted.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/data-manipulation/update":{"id":"sql-syntax/statements/data-manipulation/update","title":"UPDATE","description":"The UPDATE statement is used to modify existing records in a table. You can update one or more columns with new values, or even use subqueries to update values based on other tables.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/metadata/data-dictionary":{"id":"sql-syntax/statements/metadata/data-dictionary","title":"Data Dictionary","description":"In GlueSQL, there are predefined tables, also known as Data Dictionary tables, which store metadata about the database objects like tables, columns, and indexes. These tables can be queried like any other table in the database, and they provide useful information about the database schema.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/metadata/show-tables":{"id":"sql-syntax/statements/metadata/show-tables","title":"SHOW TABLES","description":"The SHOW TABLES statement in GlueSQL is used to display a list of tables available in the database. This statement is useful when you want to inspect the current structure of your database or when you want to manage multiple tables.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/querying/aggregation":{"id":"sql-syntax/statements/querying/aggregation","title":"Aggregation","description":"GlueSQL supports several aggregate functions to perform calculations on a set of values. Below is a list of supported aggregate functions along with a brief explanation of each:","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/querying/join":{"id":"sql-syntax/statements/querying/join","title":"JOIN","description":"GlueSQL supports two types of JOIN operations:","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/querying/limit":{"id":"sql-syntax/statements/querying/limit","title":"LIMIT & OFFSET","description":"LIMIT and OFFSET are SQL clauses that allow you to control the number of rows returned by a SELECT statement. They are particularly useful when you need to paginate or retrieve a specific portion of the result set.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/querying/schemaless":{"id":"sql-syntax/statements/querying/schemaless","title":"Schemaless Data","description":"GlueSQL is an SQL database that provides a unique feature: it allows you to work with schemaless data, similar to NoSQL databases. Please note this point in the documentation.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/querying/where":{"id":"sql-syntax/statements/querying/where","title":"WHERE","description":"In GlueSQL, the WHERE clause is used to filter the results of a SELECT query based on specific conditions. The WHERE clause can be used with various operators and functions to create complex filtering conditions.","sidebar":"sqlSyntaxSidebar"},"sql-syntax/statements/transaction":{"id":"sql-syntax/statements/transaction","title":"Transaction","description":"Transactions in SQL are a series of queries that are executed as a single unit of work. In GlueSQL, transactions help to ensure the consistency and integrity of the database. They follow the ACID properties: Atomicity, Consistency, Isolation, and Durability.","sidebar":"sqlSyntaxSidebar"},"storages/developing-custom-storages/intro":{"id":"storages/developing-custom-storages/intro","title":"Introduction","description":"With GlueSQL, you can adapt SQL and the AST Builder to a wide variety of environments. This includes file systems, key-value databases, complex NoSQL databases, and even remote APIs. As long as a system supports reading, it can support SELECT queries. If it supports both reading and writing, it can support most SQL operations, including UPDATE and DELETE.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/alter-table":{"id":"storages/developing-custom-storages/store-traits/alter-table","title":"AlterTable","description":"The AlterTable trait corresponds to the SQL ALTER TABLE statement and is used for modifying existing schemas. It is not necessary to implement the AlterTable trait. If you are dealing with data that is difficult to modify schema-wise or schemaless data, there is no need to implement the AlterTable trait. It is an optional trait that custom storage developers can choose to implement.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/custom-function":{"id":"storages/developing-custom-storages/store-traits/custom-function","title":"CustomFunction","description":"The CustomFunction trait is an optional trait for supporting user-level custom functions. Through the CustomFunction trait, you can retrieve custom functions stored in the storage system. You can choose to implement the CustomFunction trait alone or together with the CustomFunctionMut trait.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/custom-function-mut":{"id":"storages/developing-custom-storages/store-traits/custom-function-mut","title":"CustomFunctionMut","description":"By implementing both the CustomFunction and CustomFunctionMut traits, users can create, use, and delete user-level custom functions. Although GlueSQL plans to continuously add various functions, users may still find them insufficient. In such cases, users can create their own user-level custom functions to supplement the built-in functions. Additionally, if there are repetitive business logic codes, they can be stored as custom functions.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/index-mut":{"id":"storages/developing-custom-storages/store-traits/index-mut","title":"IndexMut","description":"The IndexMut trait, when implemented along with the Index trait, allows custom storage developers to provide users with the ability to create, use, and delete non-clustered indexes. Implementing the IndexMut trait enhances the storage system\'s capabilities by providing support for dynamic index management.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/index-trait":{"id":"storages/developing-custom-storages/store-traits/index-trait","title":"Index","description":"The Index trait is designed to support non-clustered indexes. If you only need to support pre-built non-clustered indexes, implementing the Index trait without the IndexMut trait is sufficient. Note that clustered indexes (PRIMARY KEY) are automatically supported by the Store & StoreMut implementations. The Index trait is specifically for non-clustered index support.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/metadata":{"id":"storages/developing-custom-storages/store-traits/metadata","title":"Metadata","description":"The Metadata trait is an optional implementation for providing additional metadata support in GlueSQL. GlueSQL does not enforce any specific metadata implementation, allowing custom storage developers to decide which type of metadata, such as create time, modify time, etc., they want to provide.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/store":{"id":"storages/developing-custom-storages/store-traits/store","title":"Store","description":"The Store trait is the most essential trait to implement for custom storage. Simply by implementing the Store trait, you can support SELECT queries in SQL. You may want to analyze and retrieve data from log files or external APIs using SQL. In this case, having only SELECT queries available is sufficient, and there might not be any need for data modification. In such scenarios, implementing GlueSQL\'s Store trait alone would be adequate.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/store-mut":{"id":"storages/developing-custom-storages/store-traits/store-mut","title":"StoreMut","description":"While the Store trait is for supporting SELECT queries and reading data, the StoreMut trait is for modifying data. Implementing the StoreMut trait requires the implementation of the Store trait as well. By implementing both the Store and StoreMut traits, you can support most of the commonly used SQL statements. Additionally, you can use the Test Suite to utilize the integration test set provided by GlueSQL. Custom storage developers can verify their own Store & StoreMut implementations by checking if they pass all the tests provided in the Test Suite.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/store-traits/transaction":{"id":"storages/developing-custom-storages/store-traits/transaction","title":"Transaction","description":"While transactions are often considered an essential feature for databases, GlueSQL treats transactions as an optional trait. Custom storage developers can choose whether or not to support transactions in their storage implementation. Transactions can be quite heavy and expensive in terms of performance.","sidebar":"customStorageSidebar"},"storages/developing-custom-storages/using-test-suite":{"id":"storages/developing-custom-storages/using-test-suite","title":"Using the Test Suite","description":"The GlueSQL Test Suite is a valuable tool for validating your custom storage implementation. By using the provided test sets, you can ensure that your storage implementation adheres to the required specifications and works as expected with GlueSQL.","sidebar":"customStorageSidebar"},"storages/intro":{"id":"storages/intro","title":"Introduction","description":"GlueSQL is not only suitable for use as a conventional database, but one of its key features is the ability for anyone to easily adapt SQL and the AST Builder to their desired file or storage system. This adaptability is achieved through the following topics covered in this section:","sidebar":"customStorageSidebar"},"storages/supported-storages/idb-storage":{"id":"storages/supported-storages/idb-storage","title":"IndexedDB Storage","description":"","sidebar":"customStorageSidebar"},"storages/supported-storages/json-storage":{"id":"storages/supported-storages/json-storage","title":"JSON Storage","description":"","sidebar":"customStorageSidebar"},"storages/supported-storages/memory-storage":{"id":"storages/supported-storages/memory-storage","title":"Memory Storage","description":"","sidebar":"customStorageSidebar"},"storages/supported-storages/shared-memory-storage":{"id":"storages/supported-storages/shared-memory-storage","title":"Shared Memory Storage","description":"","sidebar":"customStorageSidebar"},"storages/supported-storages/sled-storage":{"id":"storages/supported-storages/sled-storage","title":"Sled Storage","description":"","sidebar":"customStorageSidebar"},"storages/supported-storages/web-storage":{"id":"storages/supported-storages/web-storage","title":"Web Storage (local & session)","description":"","sidebar":"customStorageSidebar"},"tutorial-basics/congratulations":{"id":"tutorial-basics/congratulations","title":"Congratulations!","description":"You have just learned the basics of Docusaurus and made some changes to the initial template.","sidebar":"tutorialSidebar"},"tutorial-basics/create-a-blog-post":{"id":"tutorial-basics/create-a-blog-post","title":"Create a Blog Post","description":"Docusaurus creates a page for each blog post, but also a blog index page, a tag system, an RSS feed...","sidebar":"tutorialSidebar"},"tutorial-basics/create-a-document":{"id":"tutorial-basics/create-a-document","title":"Create a Document","description":"Documents are groups of pages connected through:","sidebar":"tutorialSidebar"},"tutorial-basics/create-a-page":{"id":"tutorial-basics/create-a-page","title":"Create a Page","description":"Add Markdown or React files to src/pages to create a standalone page:","sidebar":"tutorialSidebar"},"tutorial-basics/deploy-your-site":{"id":"tutorial-basics/deploy-your-site","title":"Deploy your site","description":"Docusaurus is a static-site-generator (also called Jamstack).","sidebar":"tutorialSidebar"},"tutorial-basics/markdown-features":{"id":"tutorial-basics/markdown-features","title":"Markdown Features","description":"Docusaurus supports Markdown and a few additional features.","sidebar":"tutorialSidebar"},"tutorial-extras/manage-docs-versions":{"id":"tutorial-extras/manage-docs-versions","title":"Manage Docs Versions","description":"Docusaurus can manage multiple versions of your docs."},"tutorial-extras/translate-your-site":{"id":"tutorial-extras/translate-your-site","title":"Translate your site","description":"Let\'s translate docs/intro.md to French."}}}')}}]);