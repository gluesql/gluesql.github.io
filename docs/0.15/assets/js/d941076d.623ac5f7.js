"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8662],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>f});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=o,f=u["".concat(l,".").concat(m)]||u[m]||c[m]||a;return n?r.createElement(f,i(i({ref:t},p),{},{components:n})):r.createElement(f,i({ref:t},p))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:o,i[1]=s;for(var d=2;d<a;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},483:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var r=n(7462),o=(n(7294),n(3905));const a={sidebar_position:7},i="Index",s={unversionedId:"storages/developing-custom-storages/store-traits/index-trait",id:"storages/developing-custom-storages/store-traits/index-trait",title:"Index",description:"The Index trait is designed to support non-clustered indexes. If you only need to support pre-built non-clustered indexes, implementing the Index trait without the IndexMut trait is sufficient. Note that clustered indexes (PRIMARY KEY) are automatically supported by the Store & StoreMut implementations. The Index trait is specifically for non-clustered index support.",source:"@site/docs/storages/developing-custom-storages/store-traits/index-trait.md",sourceDirName:"storages/developing-custom-storages/store-traits",slug:"/storages/developing-custom-storages/store-traits/index-trait",permalink:"/docs/0.15/storages/developing-custom-storages/store-traits/index-trait",draft:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"autoSidebar",previous:{title:"CustomFunctionMut",permalink:"/docs/0.15/storages/developing-custom-storages/store-traits/custom-function-mut"},next:{title:"IndexMut",permalink:"/docs/0.15/storages/developing-custom-storages/store-traits/index-mut"}},l={},d=[],p={toc:d},u="wrapper";function c(e){let{components:t,...n}=e;return(0,o.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"index"},"Index"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Index")," trait is designed to support non-clustered indexes. If you only need to support pre-built non-clustered indexes, implementing the ",(0,o.kt)("inlineCode",{parentName:"p"},"Index")," trait without the ",(0,o.kt)("inlineCode",{parentName:"p"},"IndexMut")," trait is sufficient. Note that clustered indexes (PRIMARY KEY) are automatically supported by the ",(0,o.kt)("inlineCode",{parentName:"p"},"Store")," & ",(0,o.kt)("inlineCode",{parentName:"p"},"StoreMut")," implementations. The ",(0,o.kt)("inlineCode",{parentName:"p"},"Index")," trait is specifically for non-clustered index support."),(0,o.kt)("p",null,"Currently, GlueSQL's query planner only supports a logical planner, so the performance of finding non-clustered indexes is not optimal yet, but it is being improved. If you want to use non-clustered indexes more precisely, using the AST Builder to directly specify the index you want to use can be a good approach."),(0,o.kt)("p",null,"A brief explanation of non-clustered and clustered indexes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Non-clustered index: A non-clustered index is an index that doesn't affect the physical ordering of the data rows in the table. Instead, it maintains a separate data structure that contains a reference to the actual data rows, allowing for faster search operations without rearranging the data itself.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Clustered index: A clustered index determines the physical order of the data in the table. In other words, the data rows are stored on disk in the same order as the index. There can be only one clustered index per table, which is usually defined by the PRIMARY KEY constraint."))),(0,o.kt)("p",null,"There is one method to implement for the ",(0,o.kt)("inlineCode",{parentName:"p"},"Index")," trait:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"scan_indexed_data"),": This method retrieves indexed data from the storage system using the provided table name, index name, sorting order, and comparison value.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"#[async_trait(?Send)]\npub trait Index {\n    async fn scan_indexed_data(\n        &self,\n        _table_name: &str,\n        _index_name: &str,\n        _asc: Option<bool>,\n        _cmp_value: Option<(&IndexOperator, Value)>,\n    ) -> Result<RowIter>;\n}\n")))}c.isMDXComponent=!0}}]);